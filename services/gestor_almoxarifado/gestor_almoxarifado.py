from datetime import datetime, date, timedelta
from typing import List, Tuple, Optional, Dict
from models.almoxarifado.almoxarifado import Almoxarifado
from models.almoxarifado.item_almoxarifado import ItemAlmoxarifado
from enums.producao.politica_producao import PoliticaProducao
from utils.logs.logger_factory import setup_logger

logger = setup_logger('GestorAlmoxarifado')


class GestorAlmoxarifado:
    def __init__(self, almoxarifado: Almoxarifado):
        self.almoxarifado = almoxarifado

    # =============================================================================
    #                     VERIFICA√á√ïES DE DISPONIBILIDADE
    # =============================================================================

    def verificar_disponibilidade(self, reservas: List[Tuple[int, float, datetime]]) -> bool:
        """Verifica se todos os itens da lista t√™m estoque dispon√≠vel"""
        for id_item, quantidade, data in reservas:
            item = self.almoxarifado.buscar_item_por_id(id_item)
            if item is None or not item.tem_estoque_para(data, quantidade):
                logger.warning(f"‚ùå Item {id_item} indispon√≠vel: quantidade {quantidade} em {data.strftime('%Y-%m-%d')}")
                return False
        return True
    
    def verificar_disponibilidade_projetada_para_data(
        self,
        id_item: int,
        data: date,
        quantidade: float = 0.0
    ) -> float:
        """
        Verifica a disponibilidade projetada de um item para uma data futura.
        - Se `quantidade` for informada, retorna True/False.
        - Se n√£o for informada, retorna a quantidade projetada.
        """
        return self.almoxarifado.verificar_disponibilidade_projetada_para_data(
            id_item=id_item,
            data=data,
            quantidade=quantidade
        )

    def verificar_estoque_atual_suficiente(self, id_item: int, quantidade: float) -> bool:
        """Verifica se h√° estoque atual suficiente (sem considerar reservas futuras)"""
        item = self.almoxarifado.buscar_item_por_id(id_item)
        if not item:
            return False
        return item.tem_estoque_atual_suficiente(quantidade)

    def verificar_disponibilidade_multiplos_itens(
        self, 
        itens_requisitados: List[Tuple[int, float]], 
        data: date
    ) -> Dict[int, bool]:
        """
        Verifica disponibilidade para m√∫ltiplos itens de uma vez.
        Otimizado para verifica√ß√µes em lote.
        """
        return self.almoxarifado.verificar_disponibilidade_multiplos_itens(
            itens_requisitados, data
        )

    # =============================================================================
    #                        OPERA√á√ïES DE RESERVA
    # =============================================================================

    def reservar_itens(self, reservas: List[Tuple[int, float, datetime]], id_ordem: int = 0, id_pedido: int = 0):
        """Reserva m√∫ltiplos itens verificando disponibilidade primeiro"""
        # Verificar disponibilidade primeiro
        if not self.verificar_disponibilidade(reservas):
            raise ValueError("‚ùå Um ou mais itens n√£o t√™m estoque suficiente para reserva")
        
        # Executar reservas
        itens_reservados = []
        try:
            for id_item, quantidade, data in reservas:
                item = self.almoxarifado.buscar_item_por_id(id_item)
                if item:
                    item.reservar(data, quantidade, id_ordem, id_pedido)
                    itens_reservados.append((id_item, quantidade, data))
                    logger.info(f"‚úÖ Reservado: {quantidade} de {item.nome} para {data.strftime('%Y-%m-%d')}")
        
        except Exception as e:
            # Rollback das reservas j√° feitas
            self._rollback_reservas(itens_reservados, id_ordem, id_pedido)
            raise e

    def _rollback_reservas(self, reservas: List[Tuple], id_ordem: int, id_pedido: int):
        """Executa rollback de reservas em caso de erro"""
        for id_item, quantidade, data in reservas:
            item = self.almoxarifado.buscar_item_por_id(id_item)
            if item:
                item.cancelar_reserva(data, quantidade, id_ordem, id_pedido)
                logger.info(f"üîÑ Rollback: cancelada reserva de {quantidade} de {item.nome}")

    def cancelar_reservas(self, reservas: List[Tuple[int, float, datetime]], id_ordem: int = 0, id_pedido: int = 0):
        """Cancela m√∫ltiplas reservas"""
        for id_item, quantidade, data in reservas:
            item = self.almoxarifado.buscar_item_por_id(id_item)
            if item:
                item.cancelar_reserva(data, quantidade, id_ordem, id_pedido)
                logger.info(f"‚ùå Cancelada reserva: {quantidade} de {item.nome} para {data.strftime('%Y-%m-%d')}")

    def cancelar_todas_reservas_pedido(self, id_pedido: int, data: Optional[datetime] = None):
        """Cancela todas as reservas de um pedido espec√≠fico"""
        self.almoxarifado.cancelar_reservas_pedido(id_pedido, data)
        logger.info(f"üîÑ Canceladas todas as reservas do pedido {id_pedido}")

    # =============================================================================
    #                        OPERA√á√ïES DE CONSUMO
    # =============================================================================

    def consumir_itens(self, consumos: List[Tuple[int, float, datetime]], id_ordem: int = 0, id_pedido: int = 0):
        """Consome m√∫ltiplos itens (reduz estoque atual)"""
        for id_item, quantidade, data in consumos:
            item = self.almoxarifado.buscar_item_por_id(id_item)
            if item:
                item.consumir(data, quantidade, id_ordem, id_pedido)
                logger.info(f"üìâ Consumido: {quantidade} de {item.nome} em {data.strftime('%Y-%m-%d')}")

    def separar_itens_para_producao(
        self,
        id_ordem: int,
        id_pedido: int,
        funcionario_id: int,
        itens: List[Tuple[int, float, datetime]]
    ):
        """
        Efetiva o consumo dos itens de uma ordem/pedido,
        registrando o funcion√°rio respons√°vel.
        """
        itens_separados = []
        
        try:
            for id_item, quantidade, data in itens:
                item = self.almoxarifado.buscar_item_por_id(id_item)
                if not item:
                    raise ValueError(f"Item {id_item} n√£o encontrado")
                
                # Verificar disponibilidade antes de consumir
                if not item.tem_estoque_para(data, quantidade):
                    raise ValueError(
                        f"Estoque insuficiente para {item.nome}: "
                        f"necess√°rio {quantidade}, dispon√≠vel {item.estoque_projetado_em(data)}"
                    )
                
                item.consumir(data, quantidade, id_ordem, id_pedido)
                itens_separados.append((id_item, item.nome, quantidade))
        
        except Exception as e:
            logger.error(f"‚ùå Erro na separa√ß√£o: {e}")
            raise e

        # Registrar separa√ß√£o bem-sucedida
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        logger.info(
            f"üì¶ Estoque separado para Ordem {id_ordem}, Pedido {id_pedido} "
            f"por Funcion√°rio {funcionario_id} em {timestamp}"
        )
        
        for id_item, nome, quantidade in itens_separados:
            logger.info(f"   - {nome}: {quantidade}")

    # =============================================================================
    #                         CONSULTAS E RELAT√ìRIOS
    # =============================================================================

    def obter_estoque_atual(self, id_item: int) -> float:
        """Retorna o estoque atual de um item"""
        return self.almoxarifado.obter_estoque_atual_item(id_item)

    def obter_estoque_projetado(self, id_item: int, data: date) -> float:
        """Retorna o estoque projetado de um item para uma data"""
        item = self.almoxarifado.buscar_item_por_id(id_item)
        return item.estoque_projetado_em(data) if item else 0.0

    def obter_item_por_id(self, id_item: int) -> Optional[ItemAlmoxarifado]:
        """Retorna um item espec√≠fico por ID"""
        return self.almoxarifado.buscar_item_por_id(id_item)

    def listar_itens_por_tipo(self, tipo_item: str) -> List[ItemAlmoxarifado]:
        """Lista itens filtrados por tipo"""
        return self.almoxarifado.buscar_itens_por_tipo(tipo_item)

    def verificar_estoque_minimo(self) -> List[Dict]:
        """
        Retorna lista de itens com pol√≠tica ESTOCADO abaixo do estoque m√≠nimo.
        Vers√£o otimizada com mais informa√ß√µes.
        """
        itens_em_alerta = []
        total_itens = len(self.almoxarifado.itens)
        
        logger.info(f"üì¶ Total de itens carregados no almoxarifado: {total_itens}")
        logger.info("üîç Verificando estoque m√≠nimo apenas para itens com pol√≠tica ESTOCADO:")

        for item in self.almoxarifado.itens:
            logger.debug(f"üß™ {item.descricao} - pol√≠tica: {item.politica_producao}")

            # Verificar apenas itens ESTOCADOS
            if item.politica_producao != PoliticaProducao.ESTOCADO:
                continue

            atual = item.estoque_atual
            minimo = item.estoque_min
            unidade = item.unidade_medida.value

            logger.debug(f"üî∏ {item.descricao} (ID {item.id_item}): {atual:.2f} / m√≠nimo {minimo:.2f} {unidade}")

            if item.esta_abaixo_do_minimo():
                logger.warning(f"   ‚ùó {item.descricao} est√° abaixo do m√≠nimo!")
                
                itens_em_alerta.append({
                    "id_item": item.id_item,
                    "nome": item.nome,
                    "descricao": item.descricao,
                    "estoque_atual": round(atual, 2),
                    "estoque_min": round(minimo, 2),
                    "estoque_max": round(item.estoque_max, 2),
                    "falta": round(minimo - atual, 2),
                    "percentual_atual": round(item.percentual_estoque_atual(), 2),
                    "dias_restantes": item.dias_de_estoque_restante(),
                    "unidade": unidade
                })
            else:
                logger.debug("   ‚úÖ Estoque suficiente.")

        return itens_em_alerta

    def gerar_relatorio_estoque_completo(self, data_referencia: Optional[date] = None) -> Dict:
        """Gera relat√≥rio completo do estado do almoxarifado"""
        if data_referencia is None:
            data_referencia = date.today()
        
        estatisticas = self.almoxarifado.estatisticas_almoxarifado()
        itens_criticos = self.verificar_estoque_minimo()
        relatorio_por_data = self.almoxarifado.relatorio_estoque_por_data(data_referencia)
        
        return {
            "data_relatorio": data_referencia.isoformat(),
            "estatisticas_gerais": estatisticas,
            "itens_criticos": itens_criticos,
            "estoque_por_item": relatorio_por_data,
            "total_itens_criticos": len(itens_criticos),
            "percentual_itens_criticos": (len(itens_criticos) / estatisticas["total_itens"] * 100) if estatisticas["total_itens"] > 0 else 0
        }

    # =============================================================================
    #                           EXIBI√á√ÉO E LOGS
    # =============================================================================

    def exibir_itens_estoque(self, data: Optional[datetime] = None):
        """Exibe itens do estoque com formata√ß√£o melhorada"""
        print("üì¶ Itens no Almoxarifado:")
        
        if not self.almoxarifado.itens:
            print("   ‚ö†Ô∏è Nenhum item encontrado no almoxarifado")
            return
        
        for item in self.almoxarifado.itens:
            if data:
                estoque = item.estoque_projetado_em(data)
                reservado = item.quantidade_reservada_em(data)
                print(
                    f"üîπ ID: {item.id_item} | {item.descricao}\n"
                    f"   üìÖ Estoque projetado ({data.strftime('%Y-%m-%d')}): {estoque:.2f} {item.unidade_medida.value}\n"
                    f"   üìã Reservado: {reservado:.2f} | Pol√≠tica: {item.politica_producao.value}\n"
                )
            else:
                status = "‚ùó Cr√≠tico" if item.esta_abaixo_do_minimo() else "‚úÖ Normal"
                print(
                    f"üîπ ID: {item.id_item} | {item.descricao}\n"
                    f"   üìä Estoque atual: {item.estoque_atual:.2f} {item.unidade_medida.value}\n"
                    f"   üìè Min/Max: {item.estoque_min:.2f} / {item.estoque_max:.2f}\n"
                    f"   üè∑Ô∏è Pol√≠tica: {item.politica_producao.value} | Status: {status}\n"
                )

    def resumir_estoque_projetado(self, data: date):
        """
        üìä Gera um resumo de estoque projetado para uma data com melhor formata√ß√£o
        """
        print(f"\nüìÖ Estoque projetado para {data.strftime('%d/%m/%Y')}:\n")
        print("=" * 80)

        itens_criticos = []
        
        for item in self.almoxarifado.itens:
            reservado = item.quantidade_reservada_em(data)
            projetado = item.estoque_projetado_em(data)
            percentual = item.percentual_estoque_atual()

            # Determinar status
            if item.politica_producao == PoliticaProducao.SOB_DEMANDA:
                status = "üîÑ SOB DEMANDA"
            elif projetado <= 0:
                status = "üö® ESGOTADO"
                itens_criticos.append(item.descricao)
            elif item.esta_abaixo_do_minimo():
                status = "‚ö†Ô∏è ABAIXO DO M√çNIMO"
                itens_criticos.append(item.descricao)
            else:
                status = "‚úÖ NORMAL"

            print(
                f"üîπ {item.descricao} (ID: {item.id_item})\n"
                f"   üìä Atual: {item.estoque_atual:.2f} | Reservado: {reservado:.2f} | Projetado: {projetado:.2f}\n"
                f"   üìà Percentual do m√°ximo: {percentual:.1f}% | {status}\n"
            )
        
        # Resumo final
        print("=" * 80)
        print(f"üìã Resumo: {len(self.almoxarifado.itens)} itens analisados")
        if itens_criticos:
            print(f"‚ö†Ô∏è {len(itens_criticos)} itens necessitam aten√ß√£o:")
            for item in itens_criticos:
                print(f"   - {item}")
        else:
            print("‚úÖ Todos os itens est√£o em situa√ß√£o normal")

    # =============================================================================
    #                            UTILIT√ÅRIOS
    # =============================================================================

    def buscar_itens_por_criterio(
        self, 
        nome_parcial: Optional[str] = None,
        tipo_item: Optional[str] = None,
        politica: Optional[str] = None,
        abaixo_minimo: bool = False
    ) -> List[ItemAlmoxarifado]:
        """Busca avan√ßada com m√∫ltiplos crit√©rios"""
        resultado = self.almoxarifado.listar_itens()
        
        if nome_parcial:
            resultado = [item for item in resultado 
                        if nome_parcial.lower() in item.nome.lower() 
                        or nome_parcial.lower() in item.descricao.lower()]
        
        if tipo_item:
            resultado = [item for item in resultado if item.tipo_item == tipo_item]
        
        if politica:
            resultado = [item for item in resultado if item.politica_producao.value == politica]
        
        if abaixo_minimo:
            resultado = [item for item in resultado if item.esta_abaixo_do_minimo()]
        
        return resultado

    def validar_almoxarifado(self) -> List[str]:
        """Valida a integridade do almoxarifado"""
        problemas = self.almoxarifado.validar_integridade()
        
        if problemas:
            logger.warning(f"‚ö†Ô∏è Encontrados {len(problemas)} problemas de integridade:")
            for problema in problemas:
                logger.warning(f"   - {problema}")
        else:
            logger.info("‚úÖ Almoxarifado validado com sucesso")
        
        return problemas

    def limpar_reservas_antigas(self, dias_atras: int = 30):
        """Remove reservas mais antigas que X dias"""
        data_limite = date.today() - timedelta(days=dias_atras)
        self.almoxarifado.limpar_reservas_expiradas(data_limite)
        logger.info(f"üßπ Removidas reservas anteriores a {data_limite}")

    def __repr__(self):
        return f"<GestorAlmoxarifado com {len(self.almoxarifado)} itens>"