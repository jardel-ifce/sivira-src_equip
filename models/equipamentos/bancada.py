from models.equipamentos.equipamento import Equipamento
from enums.equipamentos.tipo_equipamento import TipoEquipamento
from enums.producao.tipo_setor import TipoSetor
from typing import List, Tuple, Optional
from datetime import datetime
from utils.logs.logger_factory import setup_logger

# ü™µ Logger espec√≠fico para Bancada
logger = setup_logger('Bancada')


class Bancada(Equipamento):
    """
    ü™µ Classe que representa uma Bancada com controle de ocupa√ß√£o por fra√ß√µes individuais.
    Cada fra√ß√£o √© de uso exclusivo - n√£o permite sobreposi√ß√£o.
    ‚úîÔ∏è Ocupa√ß√£o individualizada por fra√ß√£o.
    ‚úîÔ∏è Cada fra√ß√£o pode estar livre ou ocupada independentemente.
    ‚úîÔ∏è Gestor controla capacidades via JSON.
    """

    # ============================================
    # üîß Inicializa√ß√£o
    # ============================================
    def __init__(
        self,
        id: int,
        nome: str,
        setor: TipoSetor,
        numero_operadores: int,
        numero_fracoes: int,
    ):
        super().__init__(
            id=id,
            nome=nome,
            setor=setor,
            numero_operadores=numero_operadores,
            tipo_equipamento=TipoEquipamento.BANCADAS,
            status_ativo=True
        )

        self.numero_fracoes = numero_fracoes

        # ü™µ Ocupa√ß√µes individualizadas por fra√ß√£o: (id_ordem, id_pedido, id_atividade, id_item, inicio, fim)
        self.fracoes_ocupacoes: List[List[Tuple[int, int, int, int, datetime, datetime]]] = [[] for _ in range(self.numero_fracoes)]

    # ==========================================================
    # üîç Consulta de Ocupa√ß√£o (para o Gestor)
    # ==========================================================
    def obter_ocupacao_fracao(self, fracao_index: int, inicio: datetime, fim: datetime) -> bool:
        """Verifica se uma fra√ß√£o est√° ocupada no per√≠odo especificado."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            return False
        
        for ocupacao in self.fracoes_ocupacoes[fracao_index]:
            if not (fim <= ocupacao[4] or inicio >= ocupacao[5]):  # h√° sobreposi√ß√£o temporal
                return True
        return False

    def obter_ocupacao_todas_fracoes(self, inicio: datetime, fim: datetime) -> List[bool]:
        """Retorna lista com o status de ocupa√ß√£o de todas as fra√ß√µes no per√≠odo especificado."""
        ocupacoes = []
        for i in range(self.numero_fracoes):
            ocupacoes.append(self.obter_ocupacao_fracao(i, inicio, fim))
        return ocupacoes

    def fracao_disponivel(self, fracao_index: int, inicio: datetime, fim: datetime) -> bool:
        """Verifica se uma fra√ß√£o est√° completamente livre no per√≠odo."""
        return not self.obter_ocupacao_fracao(fracao_index, inicio, fim)

    def fracoes_disponiveis_periodo(self, inicio: datetime, fim: datetime) -> List[int]:
        """Retorna lista de √≠ndices das fra√ß√µes completamente livres no per√≠odo."""
        fracoes_livres = []
        for i in range(self.numero_fracoes):
            if self.fracao_disponivel(i, inicio, fim):
                fracoes_livres.append(i)
        return fracoes_livres

    def quantidade_fracoes_disponiveis(self, inicio: datetime, fim: datetime) -> int:
        """Retorna quantidade de fra√ß√µes completamente livres no per√≠odo."""
        return len(self.fracoes_disponiveis_periodo(inicio, fim))

    def verificar_espaco_fracoes(self, quantidade: int, inicio: datetime, fim: datetime) -> bool:
        """Verifica se h√° fra√ß√µes suficientes completamente livres no per√≠odo."""
        return self.quantidade_fracoes_disponiveis(inicio, fim) >= quantidade

    def encontrar_fracoes_para_ocupacao(self, quantidade: int, inicio: datetime, fim: datetime) -> Optional[List[int]]:
        """Encontra fra√ß√µes completamente livres para ocupa√ß√£o."""
        fracoes_livres = self.fracoes_disponiveis_periodo(inicio, fim)
        if len(fracoes_livres) >= quantidade:
            return fracoes_livres[:quantidade]
        return None

    def obter_ocupacoes_fracao(self, fracao_index: int) -> List[Tuple[int, int, int, int, datetime, datetime]]:
        """Retorna todas as ocupa√ß√µes de uma fra√ß√£o espec√≠fica."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            return []
        return self.fracoes_ocupacoes[fracao_index].copy()

    def obter_status_fracoes(self, momento: datetime) -> List[bool]:
        """Retorna status de ocupa√ß√£o de cada fra√ß√£o em um momento espec√≠fico."""
        status = []
        for fracao_index in range(self.numero_fracoes):
            ocupado = any(
                ocupacao[4] <= momento < ocupacao[5]  # inicio <= momento < fim
                for ocupacao in self.fracoes_ocupacoes[fracao_index]
            )
            status.append(ocupado)
        return status

    def obter_proxima_liberacao(self, fracao_index: int, momento_atual: datetime) -> Optional[datetime]:
        """Retorna pr√≥ximo hor√°rio de libera√ß√£o de uma fra√ß√£o espec√≠fica."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            return None
        
        proximas_liberacoes = [
            ocupacao[5]  # fim
            for ocupacao in self.fracoes_ocupacoes[fracao_index]
            if ocupacao[5] > momento_atual
        ]
        
        return min(proximas_liberacoes) if proximas_liberacoes else None

    # ==========================================================
    # üîÑ Ocupa√ß√£o e Atualiza√ß√£o (para o Gestor)
    # ==========================================================
    def adicionar_ocupacao_fracao(
        self,
        fracao_index: int,
        id_ordem: int,
        id_pedido: int,
        id_atividade: int,
        id_item: int,
        inicio: datetime,
        fim: datetime
    ) -> bool:
        """Adiciona uma ocupa√ß√£o espec√≠fica a uma fra√ß√£o espec√≠fica."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            logger.warning(f"‚ùå √çndice de fra√ß√£o inv√°lido: {fracao_index}")
            return False

        # Verificar se fra√ß√£o est√° livre (uso exclusivo)
        if not self.fracao_disponivel(fracao_index, inicio, fim):
            logger.warning(
                f"‚ùå Fra√ß√£o {fracao_index} da {self.nome} n√£o dispon√≠vel entre {inicio.strftime('%H:%M')} e {fim.strftime('%H:%M')}."
            )
            return False

        self.fracoes_ocupacoes[fracao_index].append(
            (id_ordem, id_pedido, id_atividade, id_item, inicio, fim)
        )

        logger.info(
            f"ü™µ Ocupa√ß√£o adicionada na {self.nome} - Fra√ß√£o {fracao_index} | "
            f"Ordem {id_ordem} | Pedido {id_pedido} | Atividade {id_atividade} | Item {id_item} | "
            f"{inicio.strftime('%H:%M')} ‚Üí {fim.strftime('%H:%M')}"
        )
        return True

    def sobrescrever_ocupacao_fracao(
        self,
        fracao_index: int,
        ocupacoes: List[Tuple[int, int, int, int, datetime, datetime]]
    ) -> bool:
        """Sobrescreve completamente as ocupa√ß√µes de uma fra√ß√£o espec√≠fica."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            logger.warning(f"‚ùå √çndice de fra√ß√£o inv√°lido: {fracao_index}")
            return False

        self.fracoes_ocupacoes[fracao_index] = ocupacoes.copy()
        
        logger.info(
            f"üîÑ Ocupa√ß√µes da fra√ß√£o {fracao_index} da {self.nome} foram sobrescritas. "
            f"Total de ocupa√ß√µes: {len(ocupacoes)}"
        )
        return True

    # ==========================================================
    # üîê Ocupa√ß√£o (M√©todos de Compatibilidade)
    # ==========================================================
    def ocupar_fracoes_especificas(
        self,
        fracoes: List[int],
        id_ordem: int,
        id_pedido: int,
        id_atividade: int,
        id_item: int,
        inicio: datetime,
        fim: datetime
    ) -> bool:
        """Ocupa fra√ß√µes espec√≠ficas (mantido para compatibilidade)."""
        sucesso = True
        for fracao_index in fracoes:
            if not self.adicionar_ocupacao_fracao(
                fracao_index, id_ordem, id_pedido, id_atividade, id_item, inicio, fim
            ):
                sucesso = False

        if sucesso:
            logger.info(
                f"üì• Ocupa√ß√£o m√∫ltipla registrada na {self.nome} | "
                f"Ordem {id_ordem} | Pedido {id_pedido} | Atividade {id_atividade} | Item {id_item} | "
                f"{len(fracoes)} fra√ß√µes | {inicio.strftime('%H:%M')} ‚Üí {fim.strftime('%H:%M')} | "
                f"Fra√ß√µes: {fracoes}"
            )
        return sucesso

    def ocupar_fracoes(
        self,
        id_ordem: int,
        id_pedido: int,
        id_atividade: int,
        id_item: int,
        quantidade_fracoes: int,
        inicio: datetime,
        fim: datetime
    ) -> bool:
        """Ocupa automaticamente a quantidade de fra√ß√µes necess√°ria (mantido para compatibilidade)."""
        fracoes_para_ocupar = self.encontrar_fracoes_para_ocupacao(quantidade_fracoes, inicio, fim)
        
        if fracoes_para_ocupar is None:
            logger.warning(
                f"‚ùå Fra√ß√µes insuficientes na {self.nome} entre {inicio.strftime('%H:%M')} e {fim.strftime('%H:%M')}. "
                f"Necess√°rias: {quantidade_fracoes}, Dispon√≠veis: {self.quantidade_fracoes_disponiveis(inicio, fim)}"
            )
            return False

        return self.ocupar_fracoes_especificas(
            fracoes_para_ocupar, id_ordem, id_pedido, id_atividade, id_item, inicio, fim
        )

    def ocupar(
        self,
        id_ordem: int,
        id_pedido: int,
        id_atividade: int,
        id_item: int,
        quantidade_fracoes: int,
        inicio: datetime,
        fim: datetime
    ) -> bool:
        """M√©todo de compatibilidade para ocupa√ß√£o."""
        return self.ocupar_fracoes(
            id_ordem, id_pedido, id_atividade, id_item, quantidade_fracoes, inicio, fim
        )

    # ==========================================================
    # üîì Libera√ß√£o
    # ==========================================================
    def liberar_por_atividade(self, id_ordem: int, id_pedido: int, id_atividade: int):
        """Libera ocupa√ß√µes espec√≠ficas por atividade."""
        total_liberadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            antes = len(self.fracoes_ocupacoes[fracao_index])
            self.fracoes_ocupacoes[fracao_index] = [
                ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
                if not (ocupacao[0] == id_ordem and ocupacao[1] == id_pedido and ocupacao[2] == id_atividade)
            ]
            liberadas_fracao = antes - len(self.fracoes_ocupacoes[fracao_index])
            total_liberadas += liberadas_fracao

        if total_liberadas > 0:
            logger.info(
                f"üîì Liberadas {total_liberadas} ocupa√ß√µes da {self.nome} "
                f"para Atividade {id_atividade}, Pedido {id_pedido}, Ordem {id_ordem}."
            )
        else:
            logger.warning(
                f"üîì Nenhuma ocupa√ß√£o encontrada para liberar na {self.nome} "
                f"para Atividade {id_atividade}, Pedido {id_pedido}, Ordem {id_ordem}."
            )

    def liberar_por_pedido(self, id_ordem: int, id_pedido: int):
        """Libera ocupa√ß√µes espec√≠ficas por pedido."""
        total_liberadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            antes = len(self.fracoes_ocupacoes[fracao_index])
            self.fracoes_ocupacoes[fracao_index] = [
                ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
                if not (ocupacao[0] == id_ordem and ocupacao[1] == id_pedido)
            ]
            liberadas_fracao = antes - len(self.fracoes_ocupacoes[fracao_index])
            total_liberadas += liberadas_fracao

        if total_liberadas > 0:
            logger.info(
                f"üîì Liberadas {total_liberadas} ocupa√ß√µes da {self.nome} "
                f"para Pedido {id_pedido}, Ordem {id_ordem}."
            )
        else:
            logger.warning(
                f"üîì Nenhuma ocupa√ß√£o encontrada para liberar na {self.nome} "
                f"para Pedido {id_pedido}, Ordem {id_ordem}."
            )

    def liberar_por_ordem(self, id_ordem: int):
        """Libera ocupa√ß√µes espec√≠ficas por ordem."""
        total_liberadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            antes = len(self.fracoes_ocupacoes[fracao_index])
            self.fracoes_ocupacoes[fracao_index] = [
                ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
                if ocupacao[0] != id_ordem
            ]
            liberadas_fracao = antes - len(self.fracoes_ocupacoes[fracao_index])
            total_liberadas += liberadas_fracao

        if total_liberadas > 0:
            logger.info(
                f"üîì Liberadas {total_liberadas} ocupa√ß√µes da {self.nome} "
                f"para Ordem {id_ordem}."
            )
        else:
            logger.warning(
                f"üîì Nenhuma ocupa√ß√£o encontrada para liberar na {self.nome} "
                f"para Ordem {id_ordem}."
            )

    def liberar_ocupacoes_finalizadas(self, horario_atual: datetime):
        """Libera ocupa√ß√µes que j√° finalizaram."""
        total_liberadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            antes = len(self.fracoes_ocupacoes[fracao_index])
            self.fracoes_ocupacoes[fracao_index] = [
                ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
                if ocupacao[5] > horario_atual  # fim > horario_atual
            ]
            liberadas_fracao = antes - len(self.fracoes_ocupacoes[fracao_index])
            total_liberadas += liberadas_fracao

        if total_liberadas > 0:
            logger.info(
                f"üîì Liberadas {total_liberadas} ocupa√ß√µes da {self.nome} finalizadas at√© {horario_atual.strftime('%H:%M')}."
            )
        else:
            logger.warning(
                f"üîì Nenhuma ocupa√ß√£o finalizada encontrada para liberar na {self.nome} at√© {horario_atual.strftime('%H:%M')}."
            )
        return total_liberadas

    def liberar_todas_ocupacoes(self):
        """Limpa todas as ocupa√ß√µes de todas as fra√ß√µes."""
        total = sum(len(ocupacoes) for ocupacoes in self.fracoes_ocupacoes)
        for fracao_ocupacoes in self.fracoes_ocupacoes:
            fracao_ocupacoes.clear()
        logger.info(f"üîì Todas as {total} ocupa√ß√µes da {self.nome} foram removidas.")

    def liberar_por_intervalo(self, inicio: datetime, fim: datetime):
        """Libera ocupa√ß√µes que se sobrep√µem ao intervalo especificado."""
        total_liberadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            antes = len(self.fracoes_ocupacoes[fracao_index])
            self.fracoes_ocupacoes[fracao_index] = [
                ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
                if not (ocupacao[4] < fim and ocupacao[5] > inicio)  # remove qualquer sobreposi√ß√£o
            ]
            liberadas_fracao = antes - len(self.fracoes_ocupacoes[fracao_index])
            total_liberadas += liberadas_fracao

        if total_liberadas > 0:
            logger.info(
                f"üîì Liberadas {total_liberadas} ocupa√ß√µes da {self.nome} entre {inicio.strftime('%H:%M')} e {fim.strftime('%H:%M')}."
            )
        else:
            logger.warning(
                f"üîì Nenhuma ocupa√ß√£o encontrada para liberar na {self.nome} entre {inicio.strftime('%H:%M')} e {fim.strftime('%H:%M')}."
            )

    def liberar_fracao_especifica(self, fracao_index: int, id_ordem: int, id_pedido: int, id_atividade: int):
        """Libera ocupa√ß√£o espec√≠fica de uma fra√ß√£o."""
        if fracao_index < 0 or fracao_index >= self.numero_fracoes:
            logger.warning(f"‚ùå √çndice de fra√ß√£o inv√°lido: {fracao_index}")
            return

        antes = len(self.fracoes_ocupacoes[fracao_index])
        self.fracoes_ocupacoes[fracao_index] = [
            ocupacao for ocupacao in self.fracoes_ocupacoes[fracao_index]
            if not (ocupacao[0] == id_ordem and ocupacao[1] == id_pedido and ocupacao[2] == id_atividade)
        ]
        liberadas = antes - len(self.fracoes_ocupacoes[fracao_index])
        
        if liberadas > 0:
            logger.info(
                f"üîì Liberadas {liberadas} ocupa√ß√µes da fra√ß√£o {fracao_index} da {self.nome} "
                f"para Atividade {id_atividade}, Pedido {id_pedido}, Ordem {id_ordem}."
            )

    # ==========================================================
    # üìÖ Agenda e Relat√≥rios
    # ==========================================================
    def mostrar_agenda(self):
        """Mostra agenda detalhada por fra√ß√£o."""
        logger.info("==============================================")
        logger.info(f"üìÖ Agenda da {self.nome}")
        logger.info("==============================================")

        tem_ocupacao = False
        for fracao_index in range(self.numero_fracoes):
            if self.fracoes_ocupacoes[fracao_index]:
                tem_ocupacao = True
                logger.info(f"üîπ Fra√ß√£o {fracao_index + 1}:")
                for ocupacao in self.fracoes_ocupacoes[fracao_index]:
                    logger.info(
                        f"   ü™µ Ordem {ocupacao[0]} | Pedido {ocupacao[1]} | Atividade {ocupacao[2]} | Item {ocupacao[3]} | "
                        f"{ocupacao[4].strftime('%H:%M')} ‚Üí {ocupacao[5].strftime('%H:%M')}"
                    )

        if not tem_ocupacao:
            logger.info("üîπ Nenhuma ocupa√ß√£o registrada em nenhuma fra√ß√£o.")

    def obter_estatisticas_uso(self, inicio: datetime, fim: datetime) -> dict:
        """Retorna estat√≠sticas de uso da bancada no per√≠odo."""
        total_ocupacoes = 0
        fracoes_utilizadas = 0
        
        for fracao_index in range(self.numero_fracoes):
            ocupacoes_fracao = []
            for ocupacao in self.fracoes_ocupacoes[fracao_index]:
                if not (fim <= ocupacao[4] or inicio >= ocupacao[5]):  # h√° sobreposi√ß√£o temporal
                    ocupacoes_fracao.append(ocupacao)
            
            if ocupacoes_fracao:
                fracoes_utilizadas += 1
                total_ocupacoes += len(ocupacoes_fracao)
        
        taxa_utilizacao_fracoes = (fracoes_utilizadas / self.numero_fracoes * 100) if self.numero_fracoes > 0 else 0.0
        
        return {
            'fracoes_utilizadas': fracoes_utilizadas,
            'fracoes_total': self.numero_fracoes,
            'taxa_utilizacao_fracoes': taxa_utilizacao_fracoes,
            'total_ocupacoes': total_ocupacoes
        }

    def obter_distribuicao_fracoes_periodo(self, inicio: datetime, fim: datetime) -> dict:
        """Retorna distribui√ß√£o de uso de fra√ß√µes por atividade no per√≠odo."""
        distribuicao = {}
        
        for fracao_index in range(self.numero_fracoes):
            for ocupacao in self.fracoes_ocupacoes[fracao_index]:
                if not (fim <= ocupacao[4] or inicio >= ocupacao[5]):  # h√° sobreposi√ß√£o temporal
                    key = f"Atividade_{ocupacao[2]}"  # id_atividade
                    if key not in distribuicao:
                        distribuicao[key] = {
                            'fracoes_utilizadas': set(),
                            'ocupacoes_count': 0
                        }
                    
                    distribuicao[key]['fracoes_utilizadas'].add(fracao_index)
                    distribuicao[key]['ocupacoes_count'] += 1
        
        # Converter sets para contadores
        for key in distribuicao:
            distribuicao[key]['fracoes_utilizadas'] = len(distribuicao[key]['fracoes_utilizadas'])
        
        return distribuicao