#!/usr/bin/env python3
"""
Sistema de Menu Principal - Produ√ß√£o - DESACOPLADO
==================================================

Menu interativo para registro e execu√ß√£o de pedidos de produ√ß√£o
usando o novo GestorProducao independente dos scripts de teste.

‚úÖ NOVIDADES:
- Desacoplado dos scripts producao_paes*
- Usa services/gestor_producao
- Limpeza autom√°tica integrada
- Interface simplificada
- üÜï Limpeza autom√°tica de logs na inicializa√ß√£o
- üÜï Sistema de Ordens/Sess√µes para agrupamento de pedidos
- üÜï MODIFICA√á√ÉO: Limpeza autom√°tica de pedidos salvos (data/pedidos/pedidos_salvos.json)
"""

import os
import sys
from typing import Optional

# Adiciona paths necess√°rios
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from menu.gerenciador_pedidos import GerenciadorPedidos
from menu.utils_menu import MenuUtils
from services.gestor_producao import GestorProducao
from utils.logs.gerenciador_logs import limpar_logs_inicializacao


class MenuPrincipal:
    """Menu principal do sistema de produ√ß√£o com controle de ordens"""
    
    def __init__(self):
        print("üöÄ Inicializando Sistema de Produ√ß√£o...")
        
        # üÜï LIMPEZA AUTOM√ÅTICA DE LOGS
        try:
            # üÜï MODIFICA√á√ÉO: Agora limpar_logs_inicializacao() j√° inclui limpeza de pedidos salvos
            relatorio_limpeza = limpar_logs_inicializacao()
            
            # Como agora retorna string formatada, vamos exibir
            if isinstance(relatorio_limpeza, str):
                print(relatorio_limpeza)
            else:
                # Compatibilidade com vers√£o antiga
                if relatorio_limpeza['sucesso']:
                    if relatorio_limpeza['total_arquivos_removidos'] > 0:
                        print("‚úÖ Ambiente de logs limpo e pronto!")
                    else:
                        print("üì≠ Ambiente de logs j√° estava limpo!")
                else:
                    print("‚ö†Ô∏è Limpeza de logs conclu√≠da com alguns erros (sistema continuar√°)")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro durante limpeza de logs: {e}")
            print("üîÑ Sistema continuar√° normalmente...")
        
        print("üîß Carregando nova arquitetura desacoplada...")
        
        # Inicializa componentes
        self.gerenciador = GerenciadorPedidos()
        self.gestor_producao = GestorProducao()  # ‚úÖ NOVO: Usa GestorProducao independente
        self.utils = MenuUtils()
        self.rodando = True
        
        print("‚úÖ Sistema inicializado com arquitetura independente!")
        print(f"üì¶ Sistema de Ordens ativo - Ordem atual: {self.gerenciador.obter_ordem_atual()}")
    
    def executar(self):
        """Executa o menu principal"""
        self.utils.limpar_tela()
        self.mostrar_banner()
        
        while self.rodando:
            try:
                self.mostrar_menu_principal()
                opcao = self.obter_opcao_usuario()
                self.processar_opcao(opcao)
                
            except KeyboardInterrupt:
                print("\n\nüõë Interrompido pelo usu√°rio...")
                self.rodando = False
            except Exception as e:
                print(f"\n‚å® Erro inesperado: {e}")
                input("\nPressione Enter para continuar...")
    
    def mostrar_banner(self):
        """Mostra banner do sistema"""
        print("=" * 80)
        print("üè≠ SISTEMA DE PRODU√á√ÉO - MENU INTERATIVO")
        print("=" * 80)
        print("üìã Registre pedidos e execute com arquitetura independente")
        print("üîß Suporte a execu√ß√£o sequencial e otimizada (PL)")
        print("‚úÖ Desacoplado dos scripts de teste (producao_paes*)")
        print("üéØ Nova arquitetura: services/gestor_producao")
        print("üßπ Limpeza autom√°tica integrada")
        print("üì¶ Sistema de Ordens/Sess√µes para agrupamento")
        print()
    
    def mostrar_menu_principal(self):
        """Mostra op√ß√µes do menu principal"""
        print("\n" + "‚îÄ" * 60)
        print("üìã MENU PRINCIPAL")
        print("‚îÄ" * 60)
        
        # üÜï Status com informa√ß√µes de ordem
        ordem_atual = self.gerenciador.obter_ordem_atual()
        pedidos_ordem_atual = len(self.gerenciador.obter_pedidos_ordem_atual())
        total_pedidos = len(self.gerenciador.pedidos)
        ordens_existentes = self.gerenciador.listar_ordens_existentes()
        
        print(f"üì¶ ORDEM ATUAL: {ordem_atual}")
        print(f"üìä Status: {pedidos_ordem_atual} pedido(s) na ordem atual | {total_pedidos} total")
        
        if len(ordens_existentes) > 1:
            print(f"üìà Ordens existentes: {ordens_existentes}")
        
        # Debug: verifica duplicatas
        if total_pedidos > 0:
            ids_completos = [(p.id_ordem, p.id_pedido) for p in self.gerenciador.pedidos]
            ids_unicos = len(set(ids_completos))
            if ids_unicos != total_pedidos:
                print(f"‚ö†Ô∏è ATEN√á√ÉO: {total_pedidos - ids_unicos} duplicata(s) detectada(s)")
        
        # Status do sistema
        print("üèóÔ∏è Arquitetura: Independente (services/gestor_producao)")
        print("üßπ Limpeza: Autom√°tica (logs limpos na inicializa√ß√£o)")
        print("üì¶ Sistema: Ordens/Sess√µes ativo")
        
        if pedidos_ordem_atual == 0:
            print(f"üìÑ Ordem {ordem_atual}: Pronta para novos pedidos")
        else:
            print(f"‚è≥ Ordem {ordem_atual}: {pedidos_ordem_atual} pedido(s) aguardando execu√ß√£o")
        
        print()
        
        # Op√ß√µes do menu
        print("üìã GEST√ÉO DE PEDIDOS:")
        print("1Ô∏è‚É£  Registrar Novo Pedido")
        print("2Ô∏è‚É£  Listar Pedidos Registrados")
        print("3Ô∏è‚É£  Remover Pedido")
        print("4Ô∏è‚É£  Limpar Pedidos da Ordem Atual")
        print("5Ô∏è‚É£  Limpar Todos os Pedidos")
        print()
        print("üöÄ EXECU√á√ÉO:")
        print("6Ô∏è‚É£  Executar Ordem Atual (SEQUENCIAL)")
        print("7Ô∏è‚É£  Executar Ordem Atual (OTIMIZADO PL)")
        print()
        print("‚öôÔ∏è SISTEMA:")
        print("8Ô∏è‚É£  Testar Sistema")
        print("9Ô∏è‚É£  Configura√ß√µes")
        print("AÔ∏è‚É£  Limpar Logs Manualmente")
        print("BÔ∏è‚É£  Hist√≥rico de Ordens")  # üÜï Nova op√ß√£o
        print("CÔ∏è‚É£  Debug Sistema Ordens")  # üÜï Debug option
        print("0Ô∏è‚É£  Ajuda")
        print("[S]  Sair")
        print("‚îÄ" * 60)
    
    def obter_opcao_usuario(self) -> str:
        """Obt√©m op√ß√£o do usu√°rio"""
        return input("üéØ Escolha uma op√ß√£o: ").strip()
    
    def processar_opcao(self, opcao: str):
        """Processa op√ß√£o escolhida pelo usu√°rio"""
        
        if opcao == "1":
            self.registrar_pedido()
        
        elif opcao == "2":
            self.listar_pedidos()
        
        elif opcao == "3":
            self.remover_pedido()
        
        elif opcao == "4":
            self.limpar_ordem_atual()
        
        elif opcao == "5":
            self.limpar_todos_pedidos()
        
        elif opcao == "6":
            self.executar_sequencial()
        
        elif opcao == "7":
            self.executar_otimizado()
        
        elif opcao == "8":
            self.testar_sistema()
        
        elif opcao == "9":
            self.mostrar_configuracoes()
        
        elif opcao.lower() == "a":
            self.limpar_logs_manualmente()
        
        elif opcao.lower() == "b":  # üÜï Nova op√ß√£o
            self.mostrar_historico_ordens()
        
        elif opcao.lower() == "c":  # üÜï Debug option
            self.debug_sistema_ordens()
        
        elif opcao == "0":
            self.mostrar_ajuda()
        
        elif opcao.lower() in ["sair", "s", "quit", "exit"]:
            self.sair()
        
        else:
            print(f"\n‚å® Op√ß√£o '{opcao}' inv√°lida!")
            input("Pressione Enter para continuar...")
    
    # =========================================================================
    #                           GEST√ÉO DE PEDIDOS
    # =========================================================================
    
    def registrar_pedido(self):
        """Interface para registrar novo pedido"""
        self.utils.limpar_tela()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        proximo_pedido = len(self.gerenciador.obter_pedidos_ordem_atual()) + 1
        
        print("üìã REGISTRAR NOVO PEDIDO")
        print("=" * 40)
        print(f"üì¶ Ordem: {ordem_atual}")
        print(f"üéØ Pr√≥ximo Pedido: {proximo_pedido}")
        print(f"üè∑Ô∏è Ser√° registrado como: Ordem {ordem_atual} | Pedido {proximo_pedido}")
        print()
        
        try:
            # Solicita dados do pedido
            dados_pedido = self.utils.coletar_dados_pedido()
            
            if dados_pedido:
                # Registra o pedido
                sucesso, mensagem = self.gerenciador.registrar_pedido(**dados_pedido)
                
                if sucesso:
                    print(f"\n‚úÖ {mensagem}")
                    # Auto-salva pedidos ap√≥s registro
                    self.gerenciador.salvar_pedidos()
                else:
                    print(f"\n‚å® {mensagem}")
            else:
                print("\n‚ÑπÔ∏è Registro cancelado.")
                
        except Exception as e:
            print(f"\n‚å® Erro ao registrar pedido: {e}")
        
        input("\nPressione Enter para continuar...")
    
    def listar_pedidos(self):
        """Lista todos os pedidos registrados"""
        self.utils.limpar_tela()
        print("üìã PEDIDOS REGISTRADOS")
        print("=" * 40)
        
        if not self.gerenciador.pedidos:
            print("üì≠ Nenhum pedido registrado ainda.")
            print("\nüí° Use a op√ß√£o '1' para registrar novos pedidos")
        else:
            self.gerenciador.listar_pedidos()
            
            # Mostra estat√≠sticas
            stats = self.gerenciador.obter_estatisticas()
            if stats["total"] > 0:
                print("üìä RESUMO GERAL:")
                print(f"   Total: {stats['total']} pedidos em {stats['total_ordens']} ordem(ns)")
                print(f"   Produtos: {stats['produtos']} | Subprodutos: {stats['subprodutos']}")
                print(f"   Quantidade total: {stats['quantidade_total']} unidades")
                print(f"   Per√≠odo: {stats['inicio_mais_cedo'].strftime('%d/%m %H:%M')} ‚Üí {stats['fim_mais_tarde'].strftime('%d/%m %H:%M')}")
                print()
                print(f"üì¶ ORDEM ATUAL ({stats['ordem_atual']}):")
                print(f"   Pedidos: {stats['pedidos_ordem_atual']}")
                if stats['pedidos_ordem_atual'] > 0:
                    print("   Status: ‚è≥ Aguardando execu√ß√£o")
                else:
                    print("   Status: üìÑ Pronta para novos pedidos")
        
        input("\nPressione Enter para continuar...")
    
    def remover_pedido(self):
        """Remove um pedido espec√≠fico"""
        self.utils.limpar_tela()
        print("üóëÔ∏è REMOVER PEDIDO")
        print("=" * 40)
        
        if not self.gerenciador.pedidos:
            print("üì≠ Nenhum pedido para remover.")
            input("\nPressione Enter para continuar...")
            return
        
        # Lista pedidos primeiro
        self.gerenciador.listar_pedidos()
        
        try:
            print("üí° Formato: Digite 'Ordem Pedido' (ex: '1 2' para Ordem 1 | Pedido 2)")
            print("üí° Ou apenas o n√∫mero do pedido (buscar√° na ordem atual)")
            entrada = input("\nüéØ Digite Ordem e Pedido para remover (ou Enter para cancelar): ").strip()
            
            if entrada:
                partes = entrada.split()
                
                if len(partes) == 2:
                    # Formato: "ordem pedido"
                    id_ordem = int(partes[0])
                    id_pedido = int(partes[1])
                    sucesso, mensagem = self.gerenciador.remover_pedido(id_ordem, id_pedido)
                elif len(partes) == 1:
                    # Formato legado: apenas pedido (busca na ordem atual)
                    id_pedido = int(partes[0])
                    sucesso, mensagem = self.gerenciador.remover_pedido_legado(id_pedido)
                else:
                    print("\n‚å® Formato inv√°lido!")
                    input("Pressione Enter para continuar...")
                    return
                
                print(f"\n{'‚úÖ' if sucesso else '‚å®'} {mensagem}")
                
                if sucesso:
                    # Auto-salva ap√≥s remo√ß√£o
                    self.gerenciador.salvar_pedidos()
            else:
                print("\n‚ÑπÔ∏è Remo√ß√£o cancelada.")
                
        except ValueError:
            print("\n‚å® Formato inv√°lido! Use n√∫meros.")
        except Exception as e:
            print(f"\n‚å® Erro ao remover pedido: {e}")
        
        input("\nPressione Enter para continuar...")
    
    def limpar_ordem_atual(self):
        """üÜï Remove apenas pedidos da ordem atual"""
        self.utils.limpar_tela()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        pedidos_ordem = self.gerenciador.obter_pedidos_ordem_atual()
        
        print("üóëÔ∏è LIMPAR ORDEM ATUAL")
        print("=" * 40)
        
        if not pedidos_ordem:
            print(f"üì≠ Ordem {ordem_atual} n√£o possui pedidos para limpar.")
            input("\nPressione Enter para continuar...")
            return
        
        print(f"üì¶ Ordem atual: {ordem_atual}")
        print(f"‚ö†Ô∏è Isso remover√° {len(pedidos_ordem)} pedido(s) da ordem atual!")
        print("üí° Outras ordens n√£o ser√£o afetadas")
        
        confirmacao = input("\nDigite 'CONFIRMAR' para prosseguir: ").strip()
        
        if confirmacao == "CONFIRMAR":
            self.gerenciador.limpar_ordem_atual()
            self.gerenciador.salvar_pedidos()  # Salva estado
            print(f"\n‚úÖ Ordem {ordem_atual} limpa com sucesso.")
        else:
            print("\n‚ÑπÔ∏è Opera√ß√£o cancelada.")
        
        input("\nPressione Enter para continuar...")
    
    def limpar_todos_pedidos(self):
        """Remove todos os pedidos de todas as ordens"""
        self.utils.limpar_tela()
        print("üóëÔ∏è LIMPAR TODOS OS PEDIDOS")
        print("=" * 40)
        
        if not self.gerenciador.pedidos:
            print("üì≠ Nenhum pedido para limpar.")
            input("\nPressione Enter para continuar...")
            return
        
        total_pedidos = len(self.gerenciador.pedidos)
        ordens_existentes = self.gerenciador.listar_ordens_existentes()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        
        print(f"‚ö†Ô∏è Isso remover√° TODOS os {total_pedidos} pedidos!")
        print(f"üì¶ Ordens afetadas: {ordens_existentes}")
        print(f"üí° Ordem atual ({ordem_atual}) ser√° mantida para novos pedidos")
        
        confirmacao = input("\nDigite 'CONFIRMAR TUDO' para prosseguir: ").strip()
        
        if confirmacao == "CONFIRMAR TUDO":
            self.gerenciador.limpar_pedidos()
            self.gerenciador.salvar_pedidos()  # Salva estado vazio
            print("\n‚úÖ Todos os pedidos foram removidos.")
            print(f"üì¶ Ordem atual mantida: {ordem_atual}")
        else:
            print("\n‚ÑπÔ∏è Opera√ß√£o cancelada.")
        
        input("\nPressione Enter para continuar...")
    
    # =========================================================================
    #                              EXECU√á√ÉO
    # =========================================================================
    
    def executar_sequencial(self):
        """Executa pedidos da ordem atual em modo sequencial"""
        self.utils.limpar_tela()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        pedidos_ordem = self.gerenciador.obter_pedidos_ordem_atual()
        
        print("üîÑ EXECU√á√ÉO SEQUENCIAL")
        print("=" * 40)
        print(f"üì¶ Executando Ordem: {ordem_atual}")
        
        if not pedidos_ordem:
            print(f"üì≠ Ordem {ordem_atual} n√£o possui pedidos para executar.")
            print("\nüí° Use a op√ß√£o '1' para registrar pedidos primeiro")
            input("\nPressione Enter para continuar...")
            return
        
        print(f"üìä {len(pedidos_ordem)} pedido(s) da Ordem {ordem_atual} ser√°(√£o) executado(s).")
        print("‚è±Ô∏è Isso pode levar alguns minutos...")
        print("\nüîß M√©todo: GestorProducao.executar_sequencial()")
        print("üìã SEQUENCIAL: Execu√ß√£o otimizada sem depend√™ncias externas")
        print("üßπ Ambiente limpo automaticamente")
        print("üì¶ SISTEMA DE ORDENS: Execu√ß√£o por ordem/sess√£o")
        
        # Mostra resumo dos pedidos da ordem atual
        print(f"\nüìã Pedidos da Ordem {ordem_atual}:")
        for pedido in pedidos_ordem:
            print(f"   ‚Ä¢ Ordem {pedido.id_ordem} | Pedido {pedido.id_pedido}: {pedido.nome_item} ({pedido.quantidade} uni)")
            print(f"     Prazo: {pedido.fim_jornada.strftime('%d/%m %H:%M')}")
        
        confirmacao = input(f"\nüéØ Confirma execu√ß√£o da Ordem {ordem_atual}? (s/N): ").strip().lower()
        
        if confirmacao in ['s', 'sim', 'y', 'yes']:
            try:
                # Executa apenas pedidos da ordem atual
                sucesso = self.gestor_producao.executar_sequencial(pedidos_ordem)
                
                # üÜï SEMPRE incrementa ordem ap√≥s tentativa de execu√ß√£o (sucesso ou falha)
                nova_ordem = self.gerenciador.incrementar_ordem()
                self.gerenciador.salvar_pedidos()  # Salva nova ordem
                
                if sucesso:
                    print(f"\nüéâ Execu√ß√£o sequencial da Ordem {ordem_atual} conclu√≠da!")
                    print(f"üìà Sistema avan√ßou para Ordem {nova_ordem}")
                    print("üí° Novos pedidos ser√£o registrados na nova ordem")
                    
                    # üÜï MODIFICA√á√ÉO: Limpeza autom√°tica ap√≥s execu√ß√£o bem-sucedida
                    try:
                        from utils.logs.gerenciador_logs import limpar_arquivo_pedidos_salvos
                        print("üßπ Executando limpeza autom√°tica de pedidos salvos...")
                        if limpar_arquivo_pedidos_salvos():
                            print("‚úÖ Arquivo de pedidos salvos limpo ap√≥s execu√ß√£o bem-sucedida")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erro na limpeza p√≥s-execu√ß√£o: {e}")
                    
                    # Mostra estat√≠sticas
                    stats = self.gestor_producao.obter_estatisticas()
                    print(f"üìä Total processado: {stats.get('total_pedidos', 0)} pedidos")
                    print(f"‚è±Ô∏è Tempo de execu√ß√£o: {stats.get('tempo_execucao', 0):.1f}s")
                else:
                    print(f"\n‚å® Falha na execu√ß√£o sequencial da Ordem {ordem_atual}!")
                    print(f"üìà Mesmo assim, sistema avan√ßou para Ordem {nova_ordem}")
                    print("üí° Isso evita conflitos de IDs entre ordens com erro e novas ordens")
                    
            except Exception as e:
                # üÜï MESMO EM CASO DE EXCEPTION, incrementa ordem
                print(f"\n‚å® Erro durante execu√ß√£o: {e}")
                nova_ordem = self.gerenciador.incrementar_ordem()
                self.gerenciador.salvar_pedidos()
                print(f"üìà Ordem incrementada para {nova_ordem} (devido ao erro)")
                print("üí° Isso evita conflitos de IDs em futuras execu√ß√µes")
        else:
            print("\n‚ÑπÔ∏è Execu√ß√£o cancelada.")
        
        input("\nPressione Enter para continuar...")
    
    def executar_otimizado(self):
        """Executa pedidos da ordem atual com otimiza√ß√£o PL"""
        self.utils.limpar_tela()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        pedidos_ordem = self.gerenciador.obter_pedidos_ordem_atual()
        
        print("üöÄ EXECU√á√ÉO OTIMIZADA (PL)")
        print("=" * 40)
        print(f"üì¶ Executando Ordem: {ordem_atual}")
        
        if not pedidos_ordem:
            print(f"üì≠ Ordem {ordem_atual} n√£o possui pedidos para executar.")
            print("\nüí° Use a op√ß√£o '1' para registrar pedidos primeiro")
            input("\nPressione Enter para continuar...")
            return
        
        # Verifica OR-Tools primeiro
        ortools_ok, ortools_msg = self.utils.validar_or_tools()
        print(f"üîß OR-Tools: {'‚úÖ' if ortools_ok else '‚å®'} {ortools_msg}")
        
        if not ortools_ok:
            print("\nüí° Para instalar: pip install ortools")
            input("\nPressione Enter para continuar...")
            return
        
        print(f"\nüìä {len(pedidos_ordem)} pedido(s) da Ordem {ordem_atual} ser√°(√£o) otimizado(s).")
        print("‚è±Ô∏è Isso pode levar alguns minutos para encontrar a solu√ß√£o √≥tima...")
        print("\nüîß M√©todo: GestorProducao.executar_otimizado()")
        print("üìã OTIMIZADO: Usa Programa√ß√£o Linear independente")
        print("üßπ Ambiente limpo automaticamente")
        print("üì¶ SISTEMA DE ORDENS: Execu√ß√£o por ordem/sess√£o")
        
        # Mostra resumo dos pedidos da ordem atual
        print(f"\nüìã Pedidos da Ordem {ordem_atual} para otimiza√ß√£o:")
        for pedido in pedidos_ordem:
            print(f"   ‚Ä¢ Ordem {pedido.id_ordem} | Pedido {pedido.id_pedido}: {pedido.nome_item} ({pedido.quantidade} uni)")
            print(f"     Prazo: {pedido.fim_jornada.strftime('%d/%m %H:%M')}")
        
        confirmacao = input(f"\nüéØ Confirma execu√ß√£o otimizada da Ordem {ordem_atual}? (s/N): ").strip().lower()
        
        if confirmacao in ['s', 'sim', 'y', 'yes']:
            try:
                # Executa apenas pedidos da ordem atual
                sucesso = self.gestor_producao.executar_otimizado(pedidos_ordem)
                
                # üÜï SEMPRE incrementa ordem ap√≥s tentativa de execu√ß√£o (sucesso ou falha)
                nova_ordem = self.gerenciador.incrementar_ordem()
                self.gerenciador.salvar_pedidos()  # Salva nova ordem
                
                if sucesso:
                    print(f"\nüéâ Execu√ß√£o otimizada da Ordem {ordem_atual} conclu√≠da!")
                    print(f"üìà Sistema avan√ßou para Ordem {nova_ordem}")
                    print("üí° Novos pedidos ser√£o registrados na nova ordem")
                    
                    # üÜï MODIFICA√á√ÉO: Limpeza autom√°tica ap√≥s execu√ß√£o bem-sucedida
                    try:
                        from utils.logs.gerenciador_logs import limpar_arquivo_pedidos_salvos
                        print("üßπ Executando limpeza autom√°tica de pedidos salvos...")
                        if limpar_arquivo_pedidos_salvos():
                            print("‚úÖ Arquivo de pedidos salvos limpo ap√≥s execu√ß√£o bem-sucedida")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Erro na limpeza p√≥s-execu√ß√£o: {e}")
                    
                    # Mostra estat√≠sticas
                    stats = self.gestor_producao.obter_estatisticas()
                    print(f"üìä Total processado: {stats.get('total_pedidos', 0)} pedidos")
                    print(f"‚è±Ô∏è Tempo de execu√ß√£o: {stats.get('tempo_execucao', 0):.1f}s")
                    if stats.get('modo') == 'otimizado':
                        print(f"üéØ Solu√ß√£o: {stats.get('status_solver', 'N/A')}")
                else:
                    print(f"\n‚å® Falha na execu√ß√£o otimizada da Ordem {ordem_atual}!")
                    print(f"üìà Mesmo assim, sistema avan√ßou para Ordem {nova_ordem}")
                    print("üí° Isso evita conflitos de IDs entre ordens com erro e novas ordens")
                    
            except Exception as e:
                # üÜï MESMO EM CASO DE EXCEPTION, incrementa ordem
                print(f"\n‚å® Erro durante execu√ß√£o otimizada: {e}")
                nova_ordem = self.gerenciador.incrementar_ordem()
                self.gerenciador.salvar_pedidos()
                print(f"üìà Ordem incrementada para {nova_ordem} (devido ao erro)")
                print("üí° Isso evita conflitos de IDs em futuras execu√ß√µes")
        else:
            print("\n‚ÑπÔ∏è Execu√ß√£o cancelada.")
        
        input("\nPressione Enter para continuar...")
    
    # =========================================================================
    #                              SISTEMA
    # =========================================================================
    
    def testar_sistema(self):
        """Testa componentes do sistema"""
        self.utils.limpar_tela()
        print("üß™ TESTE DO SISTEMA")
        print("=" * 40)
        
        print("Executando diagn√≥stico completo do sistema...\n")
        
        try:
            resultados = self.gestor_producao.testar_sistema()
            
            # Resumo final
            print(f"\nüéØ DIAGN√ìSTICO CONCLU√çDO")
            
            testes_ok = sum(1 for r in resultados.values() if isinstance(r, dict) and r.get('ok', False))
            total_testes = sum(1 for r in resultados.values() if isinstance(r, dict) and 'ok' in r)
            
            if testes_ok == total_testes:
                print("‚úÖ Sistema pronto para execu√ß√£o!")
            else:
                print(f"‚ö†Ô∏è {total_testes - testes_ok} problema(s) encontrado(s)")
            
            print(f"üèóÔ∏è Arquitetura: Independente (services/gestor_producao)")
            print(f"üì¶ Sistema de Ordens: Ativo (Ordem atual: {self.gerenciador.obter_ordem_atual()})")
            
        except Exception as e:
            print(f"‚å® Erro durante teste: {e}")
        
        input("\nPressione Enter para continuar...")
    
    def mostrar_configuracoes(self):
        """Mostra configura√ß√µes do sistema"""
        self.utils.limpar_tela()
        print("‚öôÔ∏è CONFIGURA√á√ïES DO SISTEMA")
        print("=" * 40)
        
        # Informa√ß√µes do sistema
        info_sistema = self.utils.obter_info_sistema()
        print(f"üêç Python: {info_sistema['python_version']}")
        print(f"üíª Sistema: {info_sistema['platform']} {info_sistema['platform_version']}")
        print()
        
        # Configura√ß√µes dos diret√≥rios
        print(f"üìÇ Diret√≥rios:")
        print(f"   Produtos: {self.gerenciador.dir_produtos}")
        print(f"   Subprodutos: {self.gerenciador.dir_subprodutos}")
        print(f"   Pedidos salvos: {self.gerenciador.arquivo_pedidos}")
        print()
        
        # Arquitetura
        print(f"üèóÔ∏è Nova Arquitetura:")
        print(f"   Gestor: services/gestor_producao/")
        print(f"   Independente: ‚úÖ Desacoplado dos scripts de teste")
        print(f"   Limpeza: ‚úÖ Autom√°tica integrada")
        print(f"   Ordens: ‚úÖ Sistema de sess√µes ativo")
        print()
        
        # Status do sistema
        stats = self.gerenciador.obter_estatisticas()
        print(f"üìã Status:")
        print(f"   OR-Tools: {'‚úÖ Dispon√≠vel' if info_sistema['ortools_disponivel'] else '‚å® N√£o encontrado'}")
        print(f"   Ordem atual: {stats['ordem_atual']}")
        print(f"   Total de pedidos: {stats['total']} em {stats['total_ordens']} ordem(ns)")
        print(f"   Pedidos na ordem atual: {stats['pedidos_ordem_atual']}")
        
        # Op√ß√µes de configura√ß√£o
        print(f"\nüîß CONFIGURAR PAR√ÇMETROS:")
        print("1 - Configurar par√¢metros de otimiza√ß√£o")
        print("2 - Resetar ordem atual")  # üÜï Nova op√ß√£o
        print("0 - Voltar")
        
        opcao = input("\nEscolha uma op√ß√£o: ").strip()
        
        if opcao == "1":
            print("\n‚öôÔ∏è Configura√ß√£o de par√¢metros:")
            print("Digite novos valores ou pressione Enter para manter atual")
            
            try:
                # Resolu√ß√£o temporal
                atual_res = input("Resolu√ß√£o temporal em minutos (atual: 30): ").strip()
                if atual_res and int(atual_res) > 0:
                    self.gestor_producao.configurar(resolucao_minutos=int(atual_res))
                
                # Timeout
                atual_timeout = input("Timeout em segundos (atual: 300): ").strip()
                if atual_timeout and int(atual_timeout) > 0:
                    self.gestor_producao.configurar(timeout_pl=int(atual_timeout))
                    
                print("‚úÖ Configura√ß√µes atualizadas!")
                
            except ValueError:
                print("‚å® Valores inv√°lidos!")
        
        elif opcao == "2":  # üÜï Nova op√ß√£o
            print(f"\nüì¶ Resetar ordem atual:")
            print(f"Ordem atual: {self.gerenciador.obter_ordem_atual()}")
            print("‚ö†Ô∏è Isso redefinir√° a ordem para 1 e limpar√° todos os pedidos!")
            
            confirmacao = input("Digite 'RESET' para confirmar: ").strip()
            if confirmacao == "RESET":
                self.gerenciador.ordem_atual = 1
                self.gerenciador.contador_pedido = 1
                self.gerenciador.limpar_pedidos()
                self.gerenciador.salvar_pedidos()
                print("‚úÖ Sistema resetado para Ordem 1!")
            else:
                print("‚ÑπÔ∏è Reset cancelado.")
        
        input("\nPressione Enter para continuar...")
    
    def limpar_logs_manualmente(self):
        """Limpeza manual de logs"""
        self.utils.limpar_tela()
        print("üßπ LIMPEZA MANUAL DE LOGS")
        print("=" * 40)
        
        print("Esta op√ß√£o permite limpar logs manualmente durante a sess√£o.")
        print("‚ö†Ô∏è ATEN√á√ÉO: Logs s√£o limpos automaticamente na inicializa√ß√£o")
        print()
        
        print("Op√ß√µes de limpeza:")
        print("1 - Limpar todos os logs de inicializa√ß√£o + pedidos salvos")
        print("2 - Limpar apenas logs de funcion√°rios")
        print("3 - Limpar apenas logs de equipamentos")
        print("4 - Limpar apenas logs de erros")
        print("5 - Limpar apenas logs de execu√ß√µes")
        print("6 - Limpar apenas arquivo de pedidos salvos")  # üÜï MODIFICA√á√ÉO: Nova op√ß√£o
        print("0 - Voltar")
        
        opcao = input("\nüéØ Escolha uma op√ß√£o: ").strip()
        
        if opcao == "1":
            print("\nüßπ Limpando todos os logs de inicializa√ß√£o...")
            try:
                relatorio = limpar_logs_inicializacao()
                # Como pode retornar string ou dict
                if isinstance(relatorio, str):
                    print(relatorio)
                else:
                    if relatorio['sucesso']:
                        print("‚úÖ Limpeza manual conclu√≠da!")
                    else:
                        print("‚ö†Ô∏è Limpeza conclu√≠da com alguns erros")
            except Exception as e:
                print(f"‚å® Erro durante limpeza: {e}")
        
        elif opcao in ["2", "3", "4", "5"]:
            pastas_opcoes = {
                "2": "logs/funcionarios",
                "3": "logs/equipamentos", 
                "4": "logs/erros",
                "5": "logs/execucoes"
            }
            
            pasta = pastas_opcoes[opcao]
            print(f"\nüßπ Limpando pasta: {pasta}")
            
            try:
                if os.path.exists(pasta):
                    arquivos_removidos = 0
                    for arquivo in os.listdir(pasta):
                        caminho = os.path.join(pasta, arquivo)
                        if os.path.isfile(caminho):
                            os.remove(caminho)
                            arquivos_removidos += 1
                    
                    print(f"‚úÖ {arquivos_removidos} arquivo(s) removido(s) de {pasta}")
                else:
                    print(f"üìÅ Pasta {pasta} n√£o existe")
                    
            except Exception as e:
                print(f"‚å® Erro ao limpar {pasta}: {e}")
        
        elif opcao == "6":  # üÜï MODIFICA√á√ÉO: Nova op√ß√£o
            print(f"\nüßπ Limpando arquivo de pedidos salvos...")
            try:
                from utils.logs.gerenciador_logs import limpar_arquivo_pedidos_salvos
                if limpar_arquivo_pedidos_salvos():
                    print("‚úÖ Arquivo de pedidos salvos removido")
                else:
                    print("üìÑ Arquivo de pedidos salvos n√£o existia")
            except Exception as e:
                print(f"‚å® Erro ao limpar arquivo de pedidos: {e}")
        
        elif opcao == "0":
            return
        else:
            print("‚å® Op√ß√£o inv√°lida!")
        
        input("\nPressione Enter para continuar...")
    
    def mostrar_historico_ordens(self):
        """üÜï Mostra hist√≥rico de ordens executadas"""
        self.utils.limpar_tela()
        print("üìà HIST√ìRICO DE ORDENS")
        print("=" * 40)
        
        ordens_existentes = self.gerenciador.listar_ordens_existentes()
        ordem_atual = self.gerenciador.obter_ordem_atual()
        
        if not ordens_existentes:
            print("üì≠ Nenhuma ordem registrada ainda.")
            input("\nPressione Enter para continuar...")
            return
        
        print(f"üì¶ Ordem atual: {ordem_atual}")
        print(f"üìä Total de ordens com pedidos: {len(ordens_existentes)}")
        print()
        
        for ordem in ordens_existentes:
            pedidos_ordem = self.gerenciador.obter_pedidos_por_ordem(ordem)
            
            # üÜï Status mais descritivo
            if ordem == ordem_atual:
                status = "üéØ ATUAL"
            elif ordem < ordem_atual:
                status = "üìã PROCESSADA"  # Pode ter sido bem-sucedida ou ter falhado
            else:
                status = "‚ùì FUTURA"  # N√£o deveria acontecer
            
            print(f"üì¶ ORDEM {ordem} - {status}")
            print(f"   Pedidos: {len(pedidos_ordem)}")
            
            if pedidos_ordem:
                # Calcula estat√≠sticas da ordem
                quantidade_total = sum(p.quantidade for p in pedidos_ordem)
                primeiro_registro = min(p.registrado_em for p in pedidos_ordem)
                ultimo_registro = max(p.registrado_em for p in pedidos_ordem)
                
                print(f"   Quantidade total: {quantidade_total} unidades")
                print(f"   Per√≠odo de registro: {primeiro_registro.strftime('%d/%m %H:%M')} ‚Üí {ultimo_registro.strftime('%d/%m %H:%M')}")
                
                # Lista itens resumidamente
                itens_resumo = {}
                for p in pedidos_ordem:
                    if p.nome_item in itens_resumo:
                        itens_resumo[p.nome_item] += p.quantidade
                    else:
                        itens_resumo[p.nome_item] = p.quantidade
                
                print("   Itens:")
                for item, qty in itens_resumo.items():
                    print(f"      ‚Ä¢ {item}: {qty} uni")
            
            print()
        
        print("üí° LEGENDA:")
        print("   üéØ ATUAL: Ordem ativa para novos pedidos")
        print("   üìã PROCESSADA: Ordem executada (sucesso ou erro)")
        print("   ‚Ä¢ Ordens sempre incrementam ap√≥s execu√ß√£o")
        print("   ‚Ä¢ Isso garante IDs √∫nicos mesmo quando h√° erros")
        
        input("\nPressione Enter para continuar...")
    
    def debug_sistema_ordens(self):
        """üÜï Debug do sistema de ordens"""
        self.utils.limpar_tela()
        print("üîç DEBUG - SISTEMA DE ORDENS")
        print("=" * 40)
        
        self.gerenciador.debug_sistema_ordens()
        
        print("\nüîç DEBUG - ESTRUTURA DE DIRET√ìRIOS")
        print("=" * 40)
        
        estrutura = self.gerenciador.verificar_estrutura_diretorios()
        for nome, info in estrutura.items():
            status = "‚úÖ" if info["existe"] and info["eh_diretorio"] else "‚ùå"
            print(f"{status} {nome.upper()}:")
            print(f"   üìÅ Caminho: {info['caminho']}")
            print(f"   üìÇ Existe: {info['existe']}")
            print(f"   üìã √â diret√≥rio: {info['eh_diretorio']}")
            
            if nome == "pedidos_salvos":
                print(f"   üìÑ Arquivo de pedidos: {info.get('arquivo_pedidos_existe', False)}")
                if info.get('tamanho_arquivo'):
                    print(f"   üìä Tamanho: {info['tamanho_arquivo']} bytes")
                    print(f"   üïí Modificado: {info.get('modificado_em', 'N/A')}")
            print()
        
        input("\nPressione Enter para continuar...")
    
    def mostrar_ajuda(self):
        """Mostra ajuda do sistema"""
        self.utils.limpar_tela()
        print("‚ùì AJUDA DO SISTEMA")
        print("=" * 40)
        
        print("üìã COMO USAR:")
        print()
        print("1Ô∏è‚É£ SISTEMA DE ORDENS:")
        print("   ‚Ä¢ Cada sess√£o de trabalho tem uma ordem (ex: Ordem 1)")
        print("   ‚Ä¢ Pedidos s√£o numerados dentro da ordem (ex: Pedido 1, 2, 3...)")
        print("   ‚Ä¢ Formato: Ordem X | Pedido Y")
        print("   ‚Ä¢ Ap√≥s execu√ß√£o, ordem √© incrementada automaticamente")
        print()
        print("2Ô∏è‚É£ REGISTRAR PEDIDOS:")
        print("   ‚Ä¢ Digite o ID do item (ex: 1001)")
        print("   ‚Ä¢ Escolha PRODUTO ou SUBPRODUTO")
        print("   ‚Ä¢ Informe a quantidade")
        print("   ‚Ä¢ Digite fim da jornada (ex: 07:00:00 11/08/2025)")
        print("   ‚Ä¢ O in√≠cio ser√° calculado automaticamente (3 dias antes)")
        print("   ‚Ä¢ Pedido ser√° registrado na ordem atual")
        print()
        print("3Ô∏è‚É£ EXECU√á√ÉO:")
        print("   ‚Ä¢ Executa APENAS pedidos da ordem atual")
        print("   ‚Ä¢ Sequencial: R√°pido e eficiente")
        print("   ‚Ä¢ Otimizado: Usa Programa√ß√£o Linear (requer OR-Tools)")
        print("   ‚Ä¢ Ordem SEMPRE incrementa ap√≥s execu√ß√£o (sucesso ou falha)")
        print("   ‚Ä¢ Isso evita conflitos de IDs entre ordens")
        print()
        print("4Ô∏è‚É£ GERENCIAMENTO:")
        print("   ‚Ä¢ Listar: Mostra todos os pedidos agrupados por ordem")
        print("   ‚Ä¢ Remover: Remove pedido espec√≠fico (Ordem X | Pedido Y)")
        print("   ‚Ä¢ Limpar Ordem: Remove apenas pedidos da ordem atual")
        print("   ‚Ä¢ Limpar Todos: Remove todos os pedidos de todas as ordens")
        print()
        print("üèóÔ∏è ARQUITETURA:")
        print("   ‚Ä¢ Independente: N√£o depende de scripts de teste")
        print("   ‚Ä¢ Modular: services/gestor_producao")
        print("   ‚Ä¢ Limpa: Limpeza autom√°tica de logs")
        print("   ‚Ä¢ Organizada: Sistema de ordens para sess√µes")
        print()
        print("üì¶ EXEMPLO DE FLUXO:")
        print("   1. Registrar: Ordem 1 | Pedido 1 (P√£o)")
        print("   2. Registrar: Ordem 1 | Pedido 2 (Bolo)")
        print("   3. Executar Ordem 1 ‚Üí Sistema avan√ßa para Ordem 2")
        print("   4. Registrar: Ordem 2 | Pedido 1 (Cookie)")
        print("   5. Executar Ordem 2 com ERRO ‚Üí Sistema ainda avan√ßa para Ordem 3")
        print("   6. Registrar: Ordem 3 | Pedido 1 (Torta) - SEM conflito de IDs")
        print("   * Ordens incrementam SEMPRE, evitando conflitos")
        print()
        print("‚ö†Ô∏è REQUISITOS:")
        print("   ‚Ä¢ OR-Tools: pip install ortools (para otimiza√ß√£o)")
        print("   ‚Ä¢ Python 3.8+")
        print("   ‚Ä¢ Arquivos de atividades nos diret√≥rios corretos")
        
        input("\nPressione Enter para continuar...")
    
    def sair(self):
        """Sai do sistema"""
        self.utils.limpar_tela()
        print("üëã SAINDO DO SISTEMA")
        print("=" * 40)
        
        if self.gerenciador.pedidos:
            stats = self.gerenciador.obter_estatisticas()
            print(f"‚ö†Ô∏è Voc√™ tem {stats['total']} pedido(s) registrado(s).")
            print(f"üì¶ Ordem atual: {stats['ordem_atual']} ({stats['pedidos_ordem_atual']} pedidos)")
            if stats['total_ordens'] > 1:
                print(f"üìà Ordens existentes: {stats['ordens_existentes']}")
            
            salvar = input("üíæ Deseja salvar pedidos antes de sair? (S/n): ").strip().lower()
            
            if salvar in ['', 's', 'sim', 'y', 'yes']:
                try:
                    self.gerenciador.salvar_pedidos()
                    print("‚úÖ Pedidos salvos com sucesso!")
                except Exception as e:
                    print(f"‚å® Erro ao salvar: {e}")
        
        print("\nüéâ Obrigado por usar o Sistema de Produ√ß√£o!")
        print("üèóÔ∏è Nova arquitetura independente (services/gestor_producao)")
        print("üßπ Limpeza autom√°tica ativa")
        print("üì¶ Sistema de Ordens/Sess√µes implementado")
        print("=" * 40)
        self.rodando = False


def main():
    """Fun√ß√£o principal"""
    try:
        menu = MenuPrincipal()
        menu.executar()
    except Exception as e:
        print(f"\n‚å® Erro cr√≠tico: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\nüìö Sistema encerrado.")


if __name__ == "__main__":
    main()