"""
Sistema de Produ√ß√£o Otimizado - VERS√ÉO FINAL CORRIGIDA
======================================================

‚úÖ CORRE√á√ÉO FINAL: N√£o comprime janela temporal para execu√ß√£o
‚úÖ MANT√âM: Flexibilidade de 3 dias para algoritmo sequencial
‚úÖ GARANTE: Deadline obrigat√≥rio √© respeitado
"""

import sys
sys.path.append("/Users/jardelrodrigues/Desktop/SIVIRA/src_equip")

from datetime import datetime, timedelta
from typing import List, Dict, Optional
import time

# Imports das classes do otimizador
from otimizador.extrator_dados_pedidos import ExtratorDadosPedidos
from otimizador.gerador_janelas_temporais import GeradorJanelasTemporais
from otimizador.modelo_pl_otimizador import ModeloPLOtimizador, SolucaoPL


class OtimizadorIntegrado:
    """
    ‚úÖ VERS√ÉO FINAL: Mant√©m janela original para execu√ß√£o flex√≠vel
    """
    
    def __init__(self, resolucao_minutos: int = 30, timeout_segundos: int = 300):
        self.resolucao_minutos = resolucao_minutos
        self.timeout_segundos = timeout_segundos
        
        # Componentes do otimizador
        self.extrator = ExtratorDadosPedidos()
        self.gerador_janelas = None
        self.modelo_pl = None
        
        # Controle de simula√ß√£o
        self.modo_simulacao = True
        self.equipamentos_simulados = {}
        
        # ‚úÖ NOVO: Controle de hor√°rios obrigat√≥rios
        self.pedidos_com_fim_obrigatorio = {}  # {pedido_id: fim_obrigatorio}
        
        # Resultados
        self.ultima_solucao = None
        self.dados_extraidos = None
        self.estatisticas_execucao = {}
        
        print(f"‚úÖ OtimizadorIntegrado inicializado (VERS√ÉO FINAL):")
        print(f"   Resolu√ß√£o temporal: {resolucao_minutos} minutos")
        print(f"   Timeout PL: {timeout_segundos} segundos")
        print(f"   Modo simula√ß√£o: {self.modo_simulacao}")
    
    def executar_pedidos_otimizados(self, pedidos, sistema_producao) -> bool:
        """
        ‚úÖ VERS√ÉO FINAL: Pipeline completo de otimiza√ß√£o
        """
        print(f"\nüöÄ INICIANDO EXECU√á√ÉO OTIMIZADA (VERS√ÉO FINAL)")
        print("="*60)
        
        inicio_total = time.time()
        
        try:
            # ‚úÖ NOVO: FASE 0 - Detecta pedidos com hor√°rio de entrega obrigat√≥rio
            print(f"üîç Fase 0: An√°lise de restri√ß√µes temporais...")
            self._analisar_restricoes_temporais(pedidos)
            
            # FASE 1: Extra√ß√£o (sem aloca√ß√£o)
            print(f"\nüìä Fase 1: Extra√ß√£o de dados...")
            self.dados_extraidos = self.extrator.extrair_dados(pedidos)
            
            if not self.dados_extraidos:
                print(f"‚ùå Nenhum pedido v√°lido para otimiza√ß√£o")
                return False
            
            # ‚úÖ FASE 1.5: Configura√ß√£o de fins obrigat√≥rios (SEM alterar janelas)
            print(f"\nüîß Fase 1.5: Configura√ß√£o de fins obrigat√≥rios...")
            self._configurar_fins_obrigatorios()
            
            # FASE 2: Gera√ß√£o de janelas ‚úÖ CORRIGIDO: Passa fins obrigat√≥rios
            print(f"\n‚è∞ Fase 2: Gera√ß√£o de janelas temporais...")
            self.gerador_janelas = GeradorJanelasTemporais(self.resolucao_minutos)
            
            # ‚úÖ CORRE√á√ÉO CR√çTICA: Passa pedidos_com_fim_obrigatorio para o gerador
            janelas = self.gerador_janelas.gerar_janelas_todos_pedidos(
                self.dados_extraidos,
                self.pedidos_com_fim_obrigatorio  # ‚úÖ NOVO: Par√¢metro adicionado
            )
            
            # Valida√ß√£o: Verifica se h√° janelas vi√°veis
            total_janelas_viaveis = sum(
                len([j for j in janelas_pedido if j.viavel]) 
                for janelas_pedido in janelas.values()
            )
            
            if total_janelas_viaveis == 0:
                print(f"‚ùå Nenhuma janela temporal vi√°vel foi gerada!")
                self._diagnosticar_problema_janelas(janelas)
                return False
            
            print(f"‚úÖ {total_janelas_viaveis} janelas vi√°veis geradas")
            
            # FASE 3: Otimiza√ß√£o PL (SEM aloca√ß√£o real)
            print(f"\nüßÆ Fase 3: Otimiza√ß√£o com Programa√ß√£o Linear (simula√ß√£o)...")
            self.modo_simulacao = True
            
            self.modelo_pl = ModeloPLOtimizador(
                self.dados_extraidos, 
                janelas, 
                self.gerador_janelas.configuracao_tempo
            )
            
            self.ultima_solucao = self.modelo_pl.resolver(self.timeout_segundos)
            
            if not self.ultima_solucao or self.ultima_solucao.pedidos_atendidos == 0:
                print(f"‚ùå Otimiza√ß√£o PL n√£o encontrou solu√ß√£o vi√°vel")
                return False
            
            # FASE 4: Configura√ß√£o de controle (SEM alterar janelas dos pedidos)
            print(f"\nüéØ Fase 4: Configura√ß√£o de controle de deadlines...")
            sucesso_aplicacao = self._configurar_controle_deadlines(pedidos)
            
            if not sucesso_aplicacao:
                print(f"‚ùå Falha ao configurar controle de deadlines")
                return False
            
            # FASE 5: Execu√ß√£o real (AGORA sim faz aloca√ß√£o real)
            print(f"\nüè≠ Fase 5: Execu√ß√£o com aloca√ß√£o REAL...")
            self.modo_simulacao = False
            sucesso_execucao = self._executar_pedidos_com_horarios_otimizados(pedidos, sistema_producao)
            
            # FASE 6: Estat√≠sticas
            tempo_total = time.time() - inicio_total
            self._calcular_estatisticas_execucao(tempo_total)
            self._imprimir_resultado_final()
            
            return sucesso_execucao
            
        except Exception as e:
            print(f"‚ùå ERRO durante execu√ß√£o otimizada: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _analisar_restricoes_temporais(self, pedidos):
        """
        ‚úÖ NOVO: Analisa quais pedidos t√™m hor√°rio de entrega obrigat√≥rio
        """
        print(f"üîç Analisando restri√ß√µes de hor√°rio de entrega...")
        
        for pedido in pedidos:
            try:
                # For√ßa cria√ß√£o das atividades se n√£o existem
                if not hasattr(pedido, 'atividades_modulares') or not pedido.atividades_modulares:
                    print(f"   üìã Criando atividades para an√°lise do pedido {pedido.id_pedido}...")
                    pedido.criar_atividades_modulares_necessarias()
                
                # Procura pela √∫ltima atividade (maior id_atividade)
                if hasattr(pedido, 'atividades_modulares') and pedido.atividades_modulares:
                    atividades_produto = [
                        a for a in pedido.atividades_modulares 
                        if hasattr(a, 'tipo_item') and str(a.tipo_item) == 'TipoItem.PRODUTO'
                    ]
                    
                    if atividades_produto:
                        # √öltima atividade = maior id_atividade
                        ultima_atividade = max(atividades_produto, key=lambda a: a.id_atividade)
                        
                        # Verifica se tem tempo_maximo_de_espera = 0
                        if hasattr(ultima_atividade, 'tempo_maximo_de_espera'):
                            if ultima_atividade.tempo_maximo_de_espera == timedelta(0):
                                self.pedidos_com_fim_obrigatorio[pedido.id_pedido] = pedido.fim_jornada
                                print(f"   ‚ö†Ô∏è Pedido {pedido.id_pedido}: FIM OBRIGAT√ìRIO √†s {pedido.fim_jornada.strftime('%d/%m %H:%M')}")
                            else:
                                print(f"   ‚úÖ Pedido {pedido.id_pedido}: hor√°rio flex√≠vel (espera: {ultima_atividade.tempo_maximo_de_espera})")
                        else:
                            print(f"   ‚ùì Pedido {pedido.id_pedido}: sem info de tempo_maximo_de_espera")
                    else:
                        print(f"   ‚ö†Ô∏è Pedido {pedido.id_pedido}: sem atividades de produto encontradas")
                else:
                    print(f"   ‚ùå Pedido {pedido.id_pedido}: n√£o foi poss√≠vel criar atividades")
                    
            except Exception as e:
                print(f"   ‚ùå Erro ao analisar pedido {pedido.id_pedido}: {e}")
        
        total_obrigatorios = len(self.pedidos_com_fim_obrigatorio)
        total_flexiveis = len(pedidos) - total_obrigatorios
        
        print(f"üìä An√°lise conclu√≠da:")
        print(f"   Pedidos com fim obrigat√≥rio: {total_obrigatorios}")
        print(f"   Pedidos com hor√°rio flex√≠vel: {total_flexiveis}")
    
    def _configurar_fins_obrigatorios(self):
        """
        ‚úÖ CORRIGIDO: N√ÉO ajusta janela dos dados - apenas informa ao PL
        A janela original de 3 dias deve ser mantida para execu√ß√£o
        """
        if not self.pedidos_com_fim_obrigatorio:
            print(f"‚ÑπÔ∏è Nenhum ajuste necess√°rio - todos os pedidos t√™m hor√°rio flex√≠vel")
            return
        
        print(f"üîß Configurando informa√ß√£o de fins obrigat√≥rios (SEM ajustar janelas)...")
        
        for dados_pedido in self.dados_extraidos:
            if dados_pedido.id_pedido in self.pedidos_com_fim_obrigatorio:
                fim_obrigatorio = self.pedidos_com_fim_obrigatorio[dados_pedido.id_pedido]
                
                print(f"   üéØ Pedido {dados_pedido.id_pedido} tem fim obrigat√≥rio:")
                print(f"      Deadline: {fim_obrigatorio.strftime('%d/%m %H:%M')}")
                print(f"      Janela original mantida: {dados_pedido.inicio_jornada.strftime('%d/%m %H:%M')} ‚Üí {dados_pedido.fim_jornada.strftime('%d/%m %H:%M')}")
                print(f"      Dura√ß√£o: {dados_pedido.duracao_total}")
                
                # ‚úÖ N√ÉO ALTERA a janela dos dados - PL escolher√° dentro da janela original
                # Apenas registra que tem fim obrigat√≥rio para o gerador de janelas usar
    
    def _diagnosticar_problema_janelas(self, janelas):
        """
        ‚úÖ NOVO: Diagn√≥stico detalhado quando n√£o h√° janelas vi√°veis
        """
        print(f"\nüîç DIAGN√ìSTICO DO PROBLEMA:")
        
        for pedido_id, janelas_pedido in janelas.items():
            print(f"\n   Pedido {pedido_id}:")
            
            if not janelas_pedido:
                print(f"      ‚ùå Nenhuma janela gerada")
                
                # Busca dados do pedido para diagn√≥stico
                dados_pedido = next((p for p in self.dados_extraidos if p.id_pedido == pedido_id), None)
                if dados_pedido:
                    print(f"      üìä Dados do pedido:")
                    print(f"         Dura√ß√£o necess√°ria: {dados_pedido.duracao_total}")
                    print(f"         Janela dispon√≠vel: {dados_pedido.fim_jornada - dados_pedido.inicio_jornada}")
                    
                    if dados_pedido.id_pedido in self.pedidos_com_fim_obrigatorio:
                        print(f"         Tipo: FIM OBRIGAT√ìRIO")
                        print(f"         Deve terminar √†s: {self.pedidos_com_fim_obrigatorio[dados_pedido.id_pedido].strftime('%d/%m %H:%M')}")
                    else:
                        print(f"         Tipo: FLEX√çVEL")
            else:
                janelas_viaveis = [j for j in janelas_pedido if j.viavel]
                print(f"      üìä {len(janelas_viaveis)}/{len(janelas_pedido)} janelas vi√°veis")
    
    def _configurar_controle_deadlines(self, pedidos) -> bool:
        """
        ‚úÖ CORRIGIDO: N√ÉO aplica hor√°rios apertados - apenas marca deadline
        Mant√©m janela original de 3 dias para execu√ß√£o sequencial
        """
        if not self.ultima_solucao or not self.ultima_solucao.janelas_selecionadas:
            print(f"‚ùå Sem solu√ß√£o v√°lida para aplicar")
            return False
        
        pedidos_configurados = 0
        
        for pedido in pedidos:
            if pedido.id_pedido in self.ultima_solucao.janelas_selecionadas:
                janela = self.ultima_solucao.janelas_selecionadas[pedido.id_pedido]
                
                # DEBUG: Mostra hor√°rios
                print(f"   üîç DEBUG Pedido {pedido.id_pedido}:")
                print(f"      Janela original: {pedido.inicio_jornada.strftime('%d/%m %H:%M')} ‚Üí {pedido.fim_jornada.strftime('%d/%m %H:%M')}")
                print(f"      Janela otimizada: {janela.datetime_inicio.strftime('%d/%m %H:%M')} ‚Üí {janela.datetime_fim.strftime('%d/%m %H:%M')}")
                
                # ‚úÖ CORRE√á√ÉO CR√çTICA: MANTER janela original para execu√ß√£o
                # N√ÉO sobrescrever inicio_jornada e fim_jornada
                
                # Apenas registra informa√ß√£o para controle
                if pedido.id_pedido in self.pedidos_com_fim_obrigatorio:
                    fim_obrigatorio = self.pedidos_com_fim_obrigatorio[pedido.id_pedido]
                    print(f"      ‚ö†Ô∏è IMPORTANTE: Pedido tem fim obrigat√≥rio √†s {fim_obrigatorio.strftime('%d/%m %H:%M')}")
                    print(f"      ‚úÖ MANTENDO janela original de 3 dias para execu√ß√£o")
                    
                    # ‚úÖ Adiciona atributo para controle do deadline (sem alterar janela)
                    pedido._deadline_obrigatorio = fim_obrigatorio
                    pedido._horario_otimizado_inicio = janela.datetime_inicio
                    pedido._horario_otimizado_fim = janela.datetime_fim
                else:
                    print(f"      ‚úÖ Pedido flex√≠vel - mantendo janela original")
                
                # Backup dos hor√°rios originais (para poss√≠vel rollback)
                pedido._inicio_jornada_original = getattr(pedido, '_inicio_jornada_original', pedido.inicio_jornada)
                pedido._fim_jornada_original = getattr(pedido, '_fim_jornada_original', pedido.fim_jornada)
                
                # ‚úÖ MANT√âM hor√°rios originais (3 dias de flexibilidade)
                inicio_str = pedido.inicio_jornada.strftime('%d/%m %H:%M')
                fim_str = pedido.fim_jornada.strftime('%d/%m %H:%M')
                duracao = pedido.fim_jornada - pedido.inicio_jornada
                
                print(f"   ‚úÖ Pedido {pedido.id_pedido}: {inicio_str} ‚Üí {fim_str} (janela: {duracao})")
                if hasattr(pedido, '_deadline_obrigatorio'):
                    print(f"      üéØ Deadline obrigat√≥rio: {pedido._deadline_obrigatorio.strftime('%d/%m %H:%M')}")
                
                pedidos_configurados += 1
            else:
                print(f"   ‚ö†Ô∏è Pedido {pedido.id_pedido}: n√£o inclu√≠do na solu√ß√£o √≥tima")
        
        print(f"üìä Configura√ß√£o aplicada a {pedidos_configurados}/{len(pedidos)} pedidos")
        print(f"‚úÖ Janelas originais de 3 dias MANTIDAS para execu√ß√£o flex√≠vel")
        return pedidos_configurados > 0
    
    def _executar_pedidos_com_horarios_otimizados(self, pedidos, sistema_producao) -> bool:
        """
        EXECUTA pedidos com aloca√ß√£o REAL usando l√≥gica existente
        """
        pedidos_executados = 0
        pedidos_com_falha = 0
        
        # Ordena por hor√°rio de in√≠cio otimizado (se dispon√≠vel)
        pedidos_selecionados = [p for p in pedidos if p.id_pedido in self.ultima_solucao.janelas_selecionadas]
        
        if pedidos_selecionados:
            # Ordena por hor√°rio otimizado
            pedidos_ordenados = sorted(
                pedidos_selecionados,
                key=lambda p: self.ultima_solucao.janelas_selecionadas[p.id_pedido].datetime_inicio
            )
        else:
            # Fallback: ordem original
            pedidos_ordenados = pedidos
        
        print(f"üìã Executando {len(pedidos_ordenados)} pedidos em ordem otimizada...")
        
        for i, pedido in enumerate(pedidos_ordenados, 1):
            nome_produto = self._obter_nome_produto(pedido)
            inicio_str = pedido.inicio_jornada.strftime('%d/%m %H:%M')
            fim_str = pedido.fim_jornada.strftime('%d/%m %H:%M')
            
            print(f"\nüîÑ Executando pedido {i}/{len(pedidos_ordenados)}: {nome_produto}")
            print(f"   ‚è∞ Janela de execu√ß√£o: {inicio_str} ‚Üí {fim_str}")
            
            # ‚úÖ NOVO: Mostra se √© pedido com fim obrigat√≥rio
            if hasattr(pedido, '_deadline_obrigatorio'):
                deadline_str = pedido._deadline_obrigatorio.strftime('%d/%m %H:%M')
                print(f"   üéØ ENTREGA OBRIGAT√ìRIA √†s {deadline_str}")
                
                # Mostra hor√°rio otimizado como refer√™ncia
                if hasattr(pedido, '_horario_otimizado_inicio'):
                    otim_inicio = pedido._horario_otimizado_inicio.strftime('%d/%m %H:%M')
                    otim_fim = pedido._horario_otimizado_fim.strftime('%d/%m %H:%M')
                    print(f"   üìç Hor√°rio otimizado sugerido: {otim_inicio} ‚Üí {otim_fim}")
            
            try:
                # USA A L√ìGICA EXISTENTE do sistema (com aloca√ß√£o real)
                sistema_producao._executar_pedido_individual(pedido)
                
                print(f"   ‚úÖ Pedido {pedido.id_pedido} executado com sucesso")
                pedidos_executados += 1
                
            except Exception as e:
                print(f"   ‚ùå Falha no pedido {pedido.id_pedido}: {e}")
                pedidos_com_falha += 1
                
                # Rollback do pedido com falha
                if hasattr(pedido, 'rollback_pedido'):
                    pedido.rollback_pedido()
        
        print(f"\nüìä Resultado da execu√ß√£o:")
        print(f"   ‚úÖ Executados: {pedidos_executados}")
        print(f"   ‚ùå Falhas: {pedidos_com_falha}")
        
        return pedidos_executados > 0
    
    def _obter_nome_produto(self, pedido) -> str:
        """Obt√©m nome do produto do pedido"""
        try:
            if hasattr(pedido, 'ficha_tecnica_modular') and pedido.ficha_tecnica_modular:
                return getattr(pedido.ficha_tecnica_modular, 'nome', f'produto_{pedido.id_produto}')
            return f'produto_{pedido.id_produto}'
        except:
            return f'pedido_{pedido.id_pedido}'
    
    def _calcular_estatisticas_execucao(self, tempo_total: float):
        """Calcula estat√≠sticas da execu√ß√£o"""
        if not self.ultima_solucao:
            return
        
        self.estatisticas_execucao = {
            'tempo_total_otimizacao': tempo_total,
            'tempo_resolucao_pl': self.ultima_solucao.tempo_resolucao,
            'pedidos_totais': len(self.dados_extraidos),
            'pedidos_atendidos': self.ultima_solucao.pedidos_atendidos,
            'taxa_atendimento': self.ultima_solucao.estatisticas['taxa_atendimento'],
            'janelas_totais_geradas': sum(len(j) for j in self.gerador_janelas.janelas_por_pedido.values()),
            'variaveis_pl': self.ultima_solucao.estatisticas.get('total_variaveis', 0),
            'restricoes_pl': self.ultima_solucao.estatisticas.get('total_restricoes', 0),
            'status_solver': self.ultima_solucao.status_solver,
            'modo_execucao': 'otimizado_final',
            'pedidos_com_fim_obrigatorio': len(self.pedidos_com_fim_obrigatorio)
        }
    
    def _imprimir_resultado_final(self):
        """Imprime resultado final"""
        print(f"\n" + "="*80)
        print(f"üéâ EXECU√á√ÉO OTIMIZADA CONCLU√çDA (VERS√ÉO FINAL)")
        print("="*80)
        
        if not self.estatisticas_execucao:
            print(f"‚ùå Sem estat√≠sticas dispon√≠veis")
            return
        
        stats = self.estatisticas_execucao
        
        print(f"üìä RESULTADOS:")
        print(f"   Pedidos atendidos: {stats['pedidos_atendidos']}/{stats['pedidos_totais']}")
        print(f"   Taxa de atendimento: {stats['taxa_atendimento']:.1%}")
        print(f"   Status do solver: {stats['status_solver']}")
        print(f"   Pedidos com fim obrigat√≥rio: {stats['pedidos_com_fim_obrigatorio']}")
        
        print(f"\n‚è±Ô∏è PERFORMANCE:")
        print(f"   Tempo total: {stats['tempo_total_otimizacao']:.2f}s")
        print(f"   Tempo PL: {stats['tempo_resolucao_pl']:.2f}s")
        print(f"   Janelas geradas: {stats['janelas_totais_geradas']:,}")
        
        print(f"\n‚úÖ FUNCIONALIDADES IMPLEMENTADAS:")
        print(f"   ‚úÖ Detec√ß√£o autom√°tica de fins obrigat√≥rios")
        print(f"   ‚úÖ Respeito ao tempo_maximo_de_espera = 0")
        print(f"   ‚úÖ Manuten√ß√£o de janela de 3 dias para execu√ß√£o")
        print(f"   ‚úÖ Otimiza√ß√£o PL para m√∫ltiplos pedidos")
        print(f"   ‚úÖ Controle de conflitos entre equipamentos")
        
        if self.ultima_solucao and self.ultima_solucao.janelas_selecionadas:
            print(f"\nüìÖ CRONOGRAMA OTIMIZADO:")
            janelas_ordenadas = sorted(
                self.ultima_solucao.janelas_selecionadas.items(),
                key=lambda x: x[1].datetime_inicio
            )
            
            for pedido_id, janela in janelas_ordenadas:
                # Busca dados do pedido para mostrar informa√ß√µes
                for dados in self.dados_extraidos:
                    if dados.id_pedido == pedido_id:
                        nome_produto = dados.nome_produto
                        inicio_str = janela.datetime_inicio.strftime('%d/%m %H:%M')
                        fim_str = janela.datetime_fim.strftime('%d/%m %H:%M')
                        duracao = janela.datetime_fim - janela.datetime_inicio
                        
                        # Verifica se tem fim obrigat√≥rio
                        if pedido_id in self.pedidos_com_fim_obrigatorio:
                            deadline = self.pedidos_com_fim_obrigatorio[pedido_id]
                            print(f"   üéØ {nome_produto}: {inicio_str} ‚Üí {fim_str} ({duracao}) [DEADLINE: {deadline.strftime('%H:%M')}]")
                        else:
                            print(f"   ‚úÖ {nome_produto}: {inicio_str} ‚Üí {fim_str} ({duracao}) [FLEX√çVEL]")
                        break
        
        print("="*80)
    
    def restaurar_horarios_originais(self, pedidos):
        """Restaura hor√°rios originais (para rollback)"""
        for pedido in pedidos:
            if hasattr(pedido, '_inicio_jornada_original'):
                pedido.inicio_jornada = pedido._inicio_jornada_original
                pedido.fim_jornada = pedido._fim_jornada_original
                delattr(pedido, '_inicio_jornada_original')
                delattr(pedido, '_fim_jornada_original')
            
            # Remove atributos de controle
            for attr in ['_deadline_obrigatorio', '_horario_otimizado_inicio', '_horario_otimizado_fim']:
                if hasattr(pedido, attr):
                    delattr(pedido, attr)
    
    def obter_estatisticas(self) -> Dict:
        """Retorna estat√≠sticas da √∫ltima execu√ß√£o"""
        return self.estatisticas_execucao.copy() if self.estatisticas_execucao else {}
    
    def obter_cronograma_otimizado(self) -> Dict:
        """Retorna cronograma otimizado"""
        if not self.ultima_solucao or not self.ultima_solucao.janelas_selecionadas:
            return {}
        
        cronograma = {}
        for pedido_id, janela in self.ultima_solucao.janelas_selecionadas.items():
            # ‚úÖ NOVO: Inclui tanto hor√°rio otimizado quanto deadline
            cronograma_item = {
                'inicio_otimizado': janela.datetime_inicio.isoformat(),
                'fim_otimizado': janela.datetime_fim.isoformat(),
                'duracao_horas': (janela.datetime_fim - janela.datetime_inicio).total_seconds() / 3600,
                'fim_obrigatorio': pedido_id in self.pedidos_com_fim_obrigatorio
            }
            
            # Adiciona deadline se houver
            if pedido_id in self.pedidos_com_fim_obrigatorio:
                deadline = self.pedidos_com_fim_obrigatorio[pedido_id]
                cronograma_item['deadline'] = deadline.isoformat()
            
            cronograma[pedido_id] = cronograma_item
        
        return cronograma


class SistemaProducaoOtimizado:
    """Wrapper para integra√ß√£o com TesteSistemaProducao"""
    
    def __init__(self, sistema_producao_original):
        self.sistema_original = sistema_producao_original
        self.otimizador = OtimizadorIntegrado()
        
    def executar_com_otimizacao(self) -> bool:
        """Executa com otimiza√ß√£o FINAL"""
        print(f"ü•ñ SISTEMA DE PRODU√á√ÉO OTIMIZADO (VERS√ÉO FINAL)")
        print("="*60)
        
        try:
            # Fases 1-3: Mesmo do sistema original
            self.sistema_original.inicializar_almoxarifado()
            self.sistema_original.criar_pedidos_de_producao()
            self.sistema_original.ordenar_pedidos_por_prioridade()
            
            # Fase 4: Execu√ß√£o otimizada FINAL
            return self.otimizador.executar_pedidos_otimizados(
                self.sistema_original.pedidos,
                self.sistema_original
            )
            
        except Exception as e:
            print(f"‚ùå ERRO no sistema otimizado: {e}")
            return False
    
    def obter_relatorio_completo(self) -> Dict:
        """Retorna relat√≥rio completo"""
        return {
            'estatisticas_otimizacao': self.otimizador.obter_estatisticas(),
            'cronograma_otimizado': self.otimizador.obter_cronograma_otimizado(),
            'total_pedidos': len(self.sistema_original.pedidos) if hasattr(self.sistema_original, 'pedidos') else 0,
            'versao': 'final_corrigida_janelas_flexiveis'
        }


if __name__ == "__main__":
    print("üß™ Teste b√°sico do SistemaProducaoOtimizado VERS√ÉO FINAL...")
    print("‚úÖ Classes carregadas com sucesso")